#!/bin/bash

_uts.level() { echo '-l'; }
_uts.echo() { echo '-e'; }
_uts.fn() { echo '--fn; }

_uts.parse.level.flag()
{
	if test "$1" = $(_uts.level); then
		level=$2;
		shift 2;
	fi
	if test "$1" = $(_opt.echo); then
		shift;
		echo $*;
	fi;
	return $level;
}

_uts.fn.name()
{
	local level=$1;

	if test -z $level; then
		level=3;
	fi

	echo ${FUNCNAME[$level]}	
}


_uts.byebye()
{
	echo 'self destruct initaliated...'
	local i;

	for ((i=10; i>0; i--)); do
		echo $i;
		sleep 1;
	done
}

function uts.abort()
{
	local level=2;
	local args=$(_uts.parse.level.flag -e "$@");

	local fn=$(_uts.fn.name);

	2>&1 echo "$fn: error - aborting -  $@"
	2>&1 _uts.byebye;
	exit 1
}

_uts.assert()
{
	local fn=$(_uts.fn.name 3); 

	if ! $1; then 
		uts.abort "$fn - assetion failure"
	fi
	return 0;
}

_uts.abort.on.null()
{
	local val=$1;

	if test -z $val; then
		uts.abort "null value when shouldn't have been - $(_uts.fn.name 1)";
	fi
}

uts.opt.from()
{
	local opt=$1;
}

uts.split.fn()
{
	local fn1=$1;
	local fn2=$2;


	shift 2;
	
	if test $# = 0;
}

uts.is()
{
	if test "$1" =
}

function uts.call()
{
	local fn=$1;
	local subfn=$2;
}

function uts.tbd() 
{ 
    errecho "$(fnname -l 2): to be done $*";
	if arg.is $1 -x; then
		shift;
        uts errexit -k;
    fi
}


function uts.file()
{
	fn doc "return the current source file name - even if by bash 'inclusion' (source or '.' keywords)"
	fn start;

	echo ${BASH_SOURCE[0]};
}
