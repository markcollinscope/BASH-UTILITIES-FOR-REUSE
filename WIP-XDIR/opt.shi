. utils.shi

_utsfnalias() { return 0; }

if _utsfnalias; then
	echo using alias uts.
	alias utsfn=function
else
	echo not-using-alias
fi

utsfn vb.echo.
{
	vbecho $*;
}

fn.deprecated()
{
	vb.echo "$"
	eval "$@";
}


_errecho() { fn.deprecated errecho $*; }

fn.error()
{
	errecho $*;
	exiterr -k;
}

fn.echo() 
{
	echo $*
}

fn()
{
	local name=$1;

	if test -z "$name"; then 
		_errexit 'no argument given to $(fn.name)';
	fi

	if ! test "$(type -t $1)" = "function" ; then 
		_errexit "$(fn.name) argument <$1> is not function" 
	fi
	fn.echo $1;
}


fn.passthru() 
{
	local fnnm=$(arg fn $1);
	
}
fn.pass -v str.cat concat;

static()
{
	local prefix="$(fn.name)"
	declare -g $(concat)
}

_nerr.flag()
{
	
	echo 
}

arg()
{
	if test -z "$@"; then 
		err.echo "missing argument value in function: $(fn.name -l 2)"
	fi
}

	
arg.count()
{
	echo $#;
}

_isTF()
{
	arg.count 1 1 --err --msg;
	test $1 = true || test $1 =false
}

bool.init()
{
	arg.count 1
	local bval=$(arg $1)
	if _isTF $1; then 
}

arg.bool()
{
	if
}

_exitiferr()
{
	local firstbool=$(arg $1);
	local secondbool=$(arg $2)
}


_white
{
	local input=$1;
	local output=$(sed 's/ //g'); 
	if ! test $input = $output; then err.echo
	todo --msg tabs too.
}

str.match() 
{
	test "$1" = "$2";
}

str.if.error.exit()
{
	if test "$1" = "--err" ; then
		shift;
		errecho $(fnname -l 2);
	fi
}

str.match(
{
	test "$1" = "$2";
}

str.if.error.exit()
{
	if test "$1" = "--err" ; then
		shift;
		errecho $(fnname -l 2);
	fi
}
str.match() 
{
	test "$1" = "$2";
}

str.if.error.exit()
{
	if test "$1" = "--err" ; then
		shift;
		errecho $(fnname -l 2);
	fi
}

arg() 
{
	str.white --err $1;
	echo $*;
}

fn.name() { 
	fn.deprecated 



{
	if str.match $1 $(str.err); then
		shift;
		




str.len()
{
	str.white --err $*;
	local value="$@";
	echo ${#1};
}

opt.flag() 
{
	
}


opt.passon()
{
	$(opt.flag $(arg $1) );


fn.dispatch() 
{ 
	local numargs=1;
	eval $(valopt -n numargs "$@");
	for
}


opt.bool()
{
	$(boolopt --no.fn $*);
}

fn dispatch opt() 
{

}

char()
{
	eval $(boolopt --fn.echo fn.echo "$@");

	tbd single char check;
	
	fn.create char.$1
}

char --fn.echo dash '-';

opt() { str.strip $(char.dash) $1bbb
function opt.fn() { 




alias fn.tbd=function 

fn fn.dep() { vb.echo --fnname 2 ;  $1; "call to deprecated old fn $1" str 

alias tbd=fn.null
alias todo=fn.null

alias arg.all="$@";
alias str=
alias bash.str=
alias cont=\\
alias global=fn.null
alias opt.init=echo

char.lu[]() { echo $*; }

global const opt.flag [-A|--all]

todo -- $(arg str.lower -1 -A  f.*n => Fn FN fN Fn

int.init() { fn.deprecated --old f
int.zero() { test $(arg $1) = 0; }

opt.dash() 
{ 
	local num = $(arg int $1);
	const dash='-';
	if ! zero $num; then
	echo $dash $opt.dash $((num-1));
} 

opt.const
{
	local name=$(arg $1);
	opt.init 
}

ref() 
{
	eval $(fn --vb --msg

}

opt.dd() { echo --$1 }

opt.deprecated() { opt $(opt.dd dep);


fn.utsv() { echo $(str.cat v$(arg $1)'; }

types() 
{ 
	echo \
		opt str arg \
		"b.*str" 
}

types

alias const=eval

opt-$(uts 1) { const fn.null; }
opt.errflag() { const '-.*err'; }

opt.iferr() { echo opt.errflag }


local argnew=arg;
argnew 1 2 3

str.const() { declare -g $(arg $1); }

str.const glob.prefixb

global() 
{
	declare -g 
}

global opt.default=opt.flag(--default);
declare -g $(global debug --default );

alias todo=$echo

str.to_lower() { todo --autoclone and tolower; }

opt.msg() { echo '--msg'


arg opt.init 


vb.echo()
{
	eval $(boolopt --no.fn

	local fnpart=$(val fn);
	if $(boolopt)

}

arg() 
{  
	str.has-white-space --err $1;

	vb.echo --no fn --no script;
	echo  $(arg.all);
}

alias returns=
alias fn_list=function

list() { echo $*; }
fn.body() { fn.null; }



fn.clone()
{
	local oldfn=$(arg fn $1);
	declare -f $1
}

list.do_for_all()
{
	local l=$(list "$@")
}

alias retstat=function
alias fn=function

retstat ret.stat()
{
	local bval=$(arg --bool $1);

	local ret=0;
	if $1; then ret=0; else ret=1; fi
	return $ret;
}


opt.okdeprecated()
{
	eval $(boolopt --okdep OK_DEPRECATED_OPT "$@";
	
}


function fn.deprecated()
{



err.echo()
{
	errecho $*
}

err ifwhitespace
{
	# err if > 1 arg?
	local strval=$(concat $*);
	err

}


function set.init()
{
	
}

