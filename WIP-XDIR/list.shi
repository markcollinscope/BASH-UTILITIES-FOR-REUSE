. utils.shi
. sh-unit.shi

arg() # int: is a valid number (int) - forall numbers passed.
{
    eval $(boolopt int NUM_OPT "$@")

    if null "$@"; then errecho "$(fnname -l 2): null value fails test in $(fnname)"; exiterr -k; fi

    if $NUM_OPT; then
        for i in "$@"; do
            if ! isNum $i; then errecho "$(fnname -l 2): number fails test in $(fnname) args: <$@>"; exiterr -k; fi
        done
    fi

    echo "$@"
}

arg.fn()
{
	local fn=$(arg $1);
	shift;

	fn=arg.$fn;

	if fn exists "$fn"; then
		$fn "$@";
	fi
}

arg.bool()
{
	eval "$@"
	if $? ; then echo true; else echo false; fi
}

##################### for fn module 
fn()
{
	if test "$1" = 'exists'; then
		shift;
		fn.exists "$@";
	fi
}

fn.exists()
{
	test $(type -t "$1") = "function"
}


tbd() { errecho "$(fnname -l 2): to be done $*"; if test "$1" = '-x'; then errexit -k; fi; } 

#### string module ####
str.if() # ???
{ 
	if ! null "$@"; then 
		local fn=$1; shift;
		eval $fn "$@";
	fi 
}

list.encode() # -a - encode the whole list? including elements...
{
	tbd -x;
}

list.decode() # allow non-encoded. tag if encoded. # -a ?
{
	tbd -x;
}

list.errnull()
{
	if test $# = 0; then errecho "$(fnname -l 2) - null list found"; exiterr -k; fi
}

list.bounds()
{
	local lower=1;
	local value=$(arg $1)
	local upper=$(arg int $2);

	if test $value -lt $lower || test $value -gt $upper; then
		local msg="$(fnname -l 2): index out of range (index: $value lower: $lower upper: $upper)";
		errecho $msg;
		exiterr -k;
	fi
}

list.new() # -E -D
{
    echo "$@";
}

list.reverse()
{
	if ! null "$@"; then
		local head=$1;
		shift;
		local tail="$@"
		echo $(list.reverse $tail) $head;
	fi
}

list.to()
{
	local upto=$(arg int $1);
	shift;
	local len=$#;

	list.bounds $upto $len

	rev=$(list.reverse "$@");
	set -- $rev

	local shiftval=$((len-upto));
	shift $shiftval;
	echo $(list.reverse "$@");
}

list.from()
{
    local from=$(arg int $1);
	shift $((from+1));
    echo "$@";
}

list.range()
{
    local from=$(arg int $1); 
	local to=$(arg int $2); 
	shift 2;

	list.bounds $from $#
	list.bounds $to $#

    local num=$((to - from));
	echo $(list.new $(list.to $num $(list.from $from "$@")))
}

list.head()
{
	list.errnull "$@"
	echo $1;
}

list.tail()
{
	list.errnull "$@"
	shift;
    echo "$@";
}

list.len()
{
	echo $#;
}

list.null()
{
	list.new;
}

list.unexists()
{
	echo -9999
}

list.find() # <val> 
{
	eval $(valopt -m _FND_MSG "$@");

	local val=$1; shift;

	if null $val; then 
		errecho "$(fnname): no position index given $_FND_MSG";
		exiterr -k;
	fi

	local count=1;
	for i in "$@"; do
		if test $i = $val; then
			echo $count;
			return 0;
		fi
		count=$((count+1))
	done

	list.unexists;
	return 1;
}

list.contains()
{
	list.find "$@" > /dev/null;
}

list.cat()
{
	local list1=$(arg $1);
	local list2=$(arg $2);

	list.new $list1 $list2
}

list.set()
{
    local index=$(arg $1);
    local value=$(arg $2); 
    shift 2;

	local testin="$@"
    local retval;

    retval=$(list.to $((index - 1)) $testin);
    retval=$(list.append $value $retval); 
    retval=$(list.cat $retval $(list.from $index $testin));

    echo $retval;
}

list.get()
{
    local index=$(arg int $1); shift;
	local value=$1;

	getarg $index "$@";
}

list.push() 
{
	echo "$@";
}

list.popv()
{
    list.get 1 "$@";
}

list.pop()
{
    list.from 1 "$@";
}

list.append()
{
	local value=$(arg $1);

	echo $(list.new "$@" $value);
}

list.foreach()
{
	local callfn=$(arg fn $1);
	shift;

	list.new $(callfn $list.head) $(list.forall $callfn $(list.tail "$@"));
}

# list.start return iter list.next <iter>

# TEST FUNCTIONS

seqs()
{
	seq -s ' ' "$@"
}

list.new.shtest()
{
	local testin="a b c d e f g"
	local testout=$(list.new $testin);

	assertSame "$testin" "$testout"
}

list.reverse.shtest()
{
	local lower=21
	local upper=27;

	local testin=$(list.new $(seqs $lower $upper));
	local testout=$(list.reverse $testin);
	local xtestout=$(list.new $(seqs $upper -1 $lower ));

	assertSame "$testout" "$xtestout" 
}

list.to.shtest()
{
	local upper=100;
	local upto=9;

	local testin=$(list.new $(seqs 1 $upper));

	local testout=$(list.to $upto $testin);
	local xtestout=$(seqs 1 $upto);

	assertSame "$testout" "$xtestout" 
}

list.from.shtest()
{
	local upper=100;
	local from=44;

	local testin=$(list.new $(seqs 1 $upper));

	local testout=$(list.from $from $testin);
	local xtestout=$(seqs $((from+1)) $upper);

	assertSame "$testout" "$xtestout" 
}

list.range.shtest()
{
	local from=3;
	local to=11;
	local upper=12;

	local testin=$(list.new $(seqs 1 $upper));
	local testout=$(list.range $from $to $testin);
	local xtestout=$(list.new $(seqs $((from+1)) $to));

	assertSame "$testout" "$xtestout" 
}

list.head.tail.shtest()
{
	local lower=2
	local upper=14;

	local testin=$(list.new $(seqs $lower $upper));
	local testhead=$(list.head $testin)
	local xtesthead=$lower;

	assertSame "$testhead" "$xtesthead";

	local testtail=$(list.tail $testin);
	local xtesttail=$(list.new $(seqs $((lower+1)) $upper));

	assertSame "$testtail" "$xtesttail";
}

list.len.shtest()
{
	local upper=44

	local testin=$(list.new $(seqs 1 $upper));
	local testout=$(list.len $testin);
	local xtestout=$upper;

	assertSame "$testout" "$xtestout" 
}

# bool module. tbd.
bool.status()
{
	local status=$(arg $1);
	if test $status = 0; then echo true; else echo false; fi
}
# end.

list.contains.shtest()
{
	local upper=22;
	local isContained=11;
	local isNotContained=100;

	local testin=$(list.new $(seqs 1 $upper));

	list.contains $isContained $testin;
	local res=$(bool.status $?);
	assertSame $res true;

	list.contains $isNotContained $testin;
	res=$(bool.status $?);
	assertSame $res false;
}

list.find.shtest()
{
	local upper=22;
	local itemIsFound=18
	local itemIsNotFound=88;

	local testin=$(list.new $(seqs 1 $upper));
	local pos=$(list.find $itemIsFound $testin);
	assertSame $pos $itemIsFound;

	pos=$(list.find $itemIsNotFound $testin);
	assertSame $pos $(list.unexists);
}

list.get.set.shtest()
{
	local lower=1;
	local upper=17;
	local index=12;
	local newval='anewvalue';

	local testin=$(list.new $(seqs $lower $upper));
	local value=$(list.get $index $testin);
	assertSame $value $((lower + index -1));

	local testout=$(list.set $index $newval $testin);
	assertSame $(list.len $testin) $(list.len $testout);

	value=$(list.get $index $testout);
	assertSame $newval $value;
}

list.push.pop.popv,shtest()
{
	local numpush=15;
	local testin=$(list.new $(seqs 1 $upper));
	local newvalue='newvalinfn';

	local len=$(list.len $testin);
	local newlist=$(list.new $testin);
	local range=$(seqs 1 $numpush)
	local i;

	for i in $range; do
		newlist=$(list.push $newvalue $newlist);
	done
	assertSame $(list.len $newlist) $((len + numpush));

	local popvok=true; # tbd assert $value (true) # assertNot $value;
	for i in $range; do
		local val=$(list.popv $newlist)
		if ! test $val = $newvalue; then
			popvok=false;
			break;
		fi
		newlist=$(list.pop $newlist);
	done
	assertSame true $popvok;
	assertSame $testin $newlist;
}

runTests # tbd - shtest run
exit;
