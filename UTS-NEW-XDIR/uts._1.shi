# /bin/bash

# clone candidates.
# null errecho (fnecho ...) errifnull callFnIfExists exiterr -k exitok fnname no ne getarg isNum
# tmpFile evalerr isTerminalOutput setcol append (?) io.no io.ne io.none win.clear win.curpos

# LEVEL 0 FNS
# purely for uts debugging.

if $___UTS_ECHO_INTERCEPT; then

	___REALECHO=$(which echo);

	_sys.echo()
	{
		echo -n "sys.echo" >&2;
		echo "$@";
	}

	echo() 
	{
		if test "$1" = '--real'; then
			shift;
			$___REALECHO "$@";
			return 0;
		fi
		_sys.echo "$@";
	}

fi

_sys.err()	  { if ! test -z "$@"; then echo $* >&2; fi return 0; }

_sys.abort()
{
	_sys.err "
		$*
		$${FUNCNAME[1]}>: programming error (likely).

		Terminating Now.
	";

    kill 0;
}


_sys.ertn()	  { echo "$@"; }
_sys.rtn()	  { echo "eval \"return $1\""; }

_sys.out()	  { echo "$@"; }

_sys.no()	  { "$@" >/dev/null; }
_sys.ne()	  { "$@" 2>/dev/null; }
_sys.none()	  { "$@" >/dev/null 2>/dev/null; }
_sys.null()	  { test -z "$@"; }
_sys.eval()	  { eval "$@"; }

_sys.assert() { test -z "$@" && _sys.assert.err "value(s) cannot be null"; }

_sys.const()
{
	local name=$1; _sys.assert $name;
	local value=${2:-$name}

	local tpl="
		_sys.$name() 
		{
			_sys.ertn $value;
			$(_sys.rtn 0);
		}
	"
	_sys.eval $tpl;
}

_sys.const ErrStackSz 5;

_sys.stack()  
{
	local n={1:-$(_sys.ErrStackSz)};

	local res=""
	for ((i=2; i<$n; i++)); do 
		res="$FUNCNAME[$i] "' '"$res";
	done; 
	sys.ertn $res;
}

_sys.assert.err() 
{ 
	local ssz=$(_sys.ErrStackSz);

	_sys.abort "
		Assertion error [$@].
		Cannot continue.

		Call stack [max <$ssz> fns shown]: [$(_sys.stack)].
	";
}

_sys.declared()
{
	local var=$1;
	_sys.none declare -p $var
}

_sys.env()
{
	local envvarname=$1;
	local value=$2;

	if ! _sys.declared $envvarname; then

		nb: 'declare global readonly var - initialise to fn-arg(2):value.'
		_sys.eval "readonly $envvarname=$value";
		return 0;

	else 

		nb: 'variable is declared. if not assigned a value already (i.e. in env) - initialised to fn-arg(2):value.'
		local -n evar=$envvar;
		evar=${$evar:-$value};
		return 0;

	fi
	return 0;
}

_sys.env UTS_NO_DEBUG false;
_sys.const Debug true;

$(_sys.Debug) && dbg()
{
	$(_sys.Debug) && _sys.err "<${FUNCNAME[2]}>,<${FUNCNAME[1]}>: $@";
}

## basic sys stuff.

_sys.assert.unreachable.code()
{
	local fn=${FUNCNAME[1]};
	local fncaller=${FUNCNAME[2]};
    _sys.abort "$fn (called by $fncaller): assertion violation due to executing 'unreachable code'";
}


_sys.sed()
{
	local pattern=$1;
	shift;
	local values="$@";

	$(echo $values | sed "s/$pattern//g");
}

_sys.match()
{
	local pattern=$1;
	local value=$2;
	local sedvalue=$(_sys.sed $pattern $value);

	! test $value = $sedvalue;
}

_sys.assert.nows()
{
	local count=0;
	local fn=${FUNCNAME[1]};
	local fncaller=${FUNCNAME[2]}:

	for i in "$@"; do 
		count=$((count+1));
		if _sys.match ' ' $i || _sys.match '\t' $i; then

			_sys.abort "
				<$fn> [called by: <$fncaller>]: assertion error - whitespace detected in argument with value:<$i>.
				[nb: this is argument \$<$count> to function:<$fn> and likely to calling function:<$fncaller>].

			";

		fi 
	done
	return 0;
}

_sys.assert.mutually.exclusive()
{
	_sys.assert.nows "$@";

	local testvar=$1;
	local rest=$*;
}

_sys.strict() # [--on|--off]
{
	local setopt='-u'; nb: strict on.
	local flag=${1:-'--on'};

	if test --on = "$flag"; then


    set -u;
}
_sys.strict;

_sys.exit()
{
    local exitval=${1:-0};
    dbg exiting
    exit $exitval;

	_sys.assert.unreachable.code;
}

### IO basics
_io.out() { echo "$@"; }
_io.echo() { _io.out $*; }

_io.err() # [--abort]
{
    local abort=false;
    local flag=${1:-""};

    if test "$flag" = "--abort"; then
        abort=true;
        shift;
    fi
    echo "$@" >&2;
    $abort && _io.stack && _sys.abort;
}

### FN MANIPULATION/CREATION.
_fn.name()
{
    local level=${1:-1};

	level=$((level+1));
    _io.out "${FUNCNAME[$level]}";
}

_io.stack()
{
    local nlevels=${1:-10}
    local res="";
    for ((i=2;i<nlevels;i++)) do
		local fnname=$(_fn.name i);
		if ! test -z "$fnname"; then
			res=$res' '$fnname;
		fi
    done
    _io.err $res;
	return 0;
}

_fn.caller()
{
    _fn.name 2;
}

declare -g __ARGS_ERRFN="";
_args.errfn()
{
    local flag=$1;
    
    if test $flag == '--isnull'; then 
        test -z $__ARGS_ERRFN;
        return;

    elif test $flag == '--clear'; then
        __ARGS_ERRFN=$2;
        return 0;

    elif test $flag == '--set' && _args.errfn --isnull; then
        __ARGS_ERRFN=$2;
        return 0;
    
    elif test $flag == '--set' && _args.errfn --isnull; then
        # do nothing.
        return 0;

    elif test $flag == '--get' && ! _args.errfn --isnull; then
        _io.out $__ARGS_ERRFN;
        return 0;

    elif test $flag == '--get' && _args.errfn --isnull; then
        _io.err "$(_fn.name): cannot get args when fn is not set";
        _sys.abort;
    fi
    
    _io.err "$(_fn.name): unknown flag <$flag>";
    _sys.abort;
}
###

## std sed filters.
_sed.rmws()
{
	sed 's/ //g';
}

_args.ws()
{
    for i in "$@"; do 
        local in="$i";
		local out=$(_io.out "$in" | _sed.rmws);
        if ! test "$in" == "$out"; then
			local msg="
				Error in Function: <$(_args.errfn --get)>
				Illigal whitespace in a function call argument (value: <$in>)";
            _io.err
            _io.err "Call Stack: "$(_fn.stack);
            _io.err
            _sys.abort;
        fi 
    done
    return 0;
}

_arg()
{   
	dbg here1
    _args.errfn --set $(_fn.caller)
	dbg here2

    local arg="$1";
    _args.ws $arg
    
    if test -z "$arg"; then
        local caller=$(_fn.caller);
        _io.err "$caller: empty arg value";
        _sys.abort;
    fi

    _args.ws "$1";
    _io.out $1;

    _args.errfn --clear;
}


# more advance _fn stuff.
_fn.clone()
{
    local fromfn=$(_arg $1);
    local tofn=$(_arg $2);

    if ! test $(type -t $fromfn) = "function"; then
        _io.err "$(_fn.name): attemps to clone non existant function <$fromfn>";
        _sys.abort;
    fi
    
    local clonebody=$(declare -f $fromfn | grep -v $fromfn);
    
    local tpl="
        $tofn()
        $clonebody
    ";

    eval $tpl
}

# null arg, ws arg, abort msgs, ...
#

nb:() { :; }

nb: below makes a difference. no err. with set -u, there is an error. 
nb: but with below also fn.error.

set +u

egfn()
{
    local a1=$(_arg $1);
    local a2=$(_arg ${2-'default'});

    _io.out $a1 $a2
}

egfn 'ws ws' hithere;
