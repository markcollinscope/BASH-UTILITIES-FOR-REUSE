# /bin/bash

# clone candidates.
# null errecho (fnecho ...) errifnull callFnIfExists exiterr -k exitok fnname no ne getarg isNum
# tmpFile evalerr isTerminalOutput setcol append (?) io.no io.ne io.none win.clear win.curpos

# LEVEL 0 FNS
# purely for uts debugging.

nb:() { : ; }

if $___UTS_ECHO_INTERCEPT; then

	___REALECHO=$(which echo);

	_sys.echo()
	{
		$___REALECHO "$@";
	}

	echo() 
	{
		if test "$1" = '--real'; then
			shift;
			$___REALECHO "$@";
			return 0;
		fi
		_sys.echo "$@";
	}

fi

_sys.err()	  { if ! test -z "$@"; then echo $* >&2; fi; return 0; }

_sys.abort()
{
	_sys.err "
		$*
		$${FUNCNAME[1]}>: programming error (likely).

		Terminating Now.
	";

    kill 0;
}


_sys.ertn()	  { echo "$@"; }
_sys.rtn()	  { echo "eval return $1"; }

_sys.out()	  { echo "$@"; }

_sys.no()	  { "$@" >/dev/null; }
_sys.ne()	  { "$@" 2>/dev/null; }
_sys.none()	  { "$@" >/dev/null 2>/dev/null; }
_sys.null()	  { test -z "$@"; }
_sys.eval()	  { eval "$@"; }

_sys.assert() { test -z "$@" && _sys.assert.err "value(s) cannot be null"; }

_sys.const()
{
	local name=$1; _sys.assert $name;
	local value=${2:-$name}

	local tpl="
		_sys.$name() 
		{
			_sys.ertn $value;
			$(_sys.rtn 0);
		}
	"
	_sys.eval $tpl;
}

_sys.const ErrStackSz 5;
echo STACK: $(_sys.ErrStackSz)

_sys.stack()  
{
	local ss=$(_sys.ErrStackSz);
	local n=${1:-$ss}

	local res=""
	for ((i=2; i<$n; i++)); do 
		res="$FUNCNAME[$i] "' '"$res";
	done; 
	_sys.ertn $res;
}

_sys.assert.err() 
{ 
	local ssz=$(_sys.ErrStackSz);

	_sys.abort "
		Assertion error [$@].
		Cannot continue.

		Call stack [max <$ssz> fns shown]: [$(_sys.stack)].
	";
}

_sys.declared()
{
	local var=$1; _sys.assert $var;

	_sys.none declare -p $var
}

_sys.env()
{
	local envvarname=$1; _sys.assert $envvarname;
	local value=${2:-""};

	if ! _sys.declared $envvarname; then

		nb: 'declare global readonly var - initialise to fn-arg(2):value.'
		_sys.eval "readonly $envvarname=$value";
		$(_sys.rtn);

	else 

		nb: 'variable is declared. if not assigned a value already (i.e. in env) - initialised to fn-arg(2):value.'
		local -n evar=$envvar;
		evar=${$evar:-$value};
		$(_sys.rtn);

	fi
}

_sys.env UTS_NO_DEBUG false;
_sys.const Debug true;

$(_sys.Debug) && dbg()
{
	$(_sys.Debug) && _sys.err "<${FUNCNAME[2]}>,<${FUNCNAME[1]}>: $@";
}

## basic sys stuff.

_sys.assert.unreachable()
{
	local fn=${FUNCNAME[1]};
	local fncaller=${FUNCNAME[2]};

    _sys.abort "$fn (called by $fncaller): assertion violation due to executing 'unreachable code'";
}


_sys.sed()
{
	local pattern=$1; _sys.assert $pattern;
	shift;

	local values="$@";

	$(echo $values | sed "s/$pattern//g");
}

_sys.match()
{
	local pattern=$1; _sys.assert $pattern;
	local value=$2; _sys.assert $value;

	local sedvalue=$(_sys.sed $pattern $value);
	! test "$value" = "$sedvalue";
}

_sys.assert.nows()
{
	local count=0;
	local fn=${FUNCNAME[1]};
	local fncaller=${FUNCNAME[2]}:

	for i in "$@"; do 
		count=$((count+1));
		if _sys.match ' ' $i || _sys.match '\t' $i; then

			_sys.abort "
				<$fn> [called by: <$fncaller>]: assertion error - whitespace detected in argument with value:<$i>.
				[nb: this is argument \$<$count> to function:<$fn> and likely to calling function:<$fncaller>].

			";

		fi 
	done
	return 0;
}

_sys.assert.mutually.exclusive()
{
	_sys.assert.nows "$@";

	local testvar=$1;
	local rest=$*;
}

_sys.strict() # [--on|--off]
{
	local flag=${1:-'--on'};

	if test --on = "$flag"; then
		set -u;
		return;
	elif test --off = "$flag"; then
		set +u;
		return;
	elif test $# = '0'; then
		set -u;
		return;
	fi
	_sys.abort "${FUNCNAME[1]}: unknown argument error <$@>";
}
_sys.strict --on;
_sys.strict --off
_sys.strict --on;
_sys.strict

_sys.exit()
{
    local exitval=${1:-0};
    exit $exitval;

	_sys.assert.unreachable;
}

### IO basics
_sys.out() { echo "$@"; }
_io.echo() { _sys.out $*; }

_io.err() # [--abort]
{
    local abort=false;
    local flag=${1:-""};

    if test "$flag" = "--abort"; then
        abort=true;
        shift;
    fi
    echo "$@" >&2;
    $abort && _io.stack && _sys.abort;
}

### FN MANIPULATION/CREATION.
_fn.name()
{
    local level=${1:-1};

	level=$((level+1));
    _sys.out "${FUNCNAME[$level]}";
}

_io.stack()
{
    local nlevels=${1:-10}
    local res="";
    for ((i=2;i<nlevels;i++)) do
		local fnname=$(_fn.name i);
		if ! test -z "$fnname"; then
			res=$res' '$fnname;
		fi
    done
    _io.err $res;
	return 0;
}

_fn.caller()
{
    _fn.name 2;
}

if false; then
declare -g __sys.argS_ERRFN="";
_sys.args.errfn()
{
    local flag=$1;
    
    if test $flag == '--isnull'; then 
        test -z $__sys.argS_ERRFN;


        return;

    elif test $flag == '--clear'; then
        __sys.argS_ERRFN=$2;
        return 0;

    elif test $flag == '--set' && _sys.args.errfn --isnull; then
        __sys.argS_ERRFN=$2;
        return 0;
    
    elif test $flag == '--set' && _sys.args.errfn --isnull; then
        # do nothing.
        return 0;

    elif test $flag == '--get' && ! _sys.args.errfn --isnull; then
        _sys.out $__sys.argS_ERRFN;
        return 0;

    elif test $flag == '--get' && _sys.args.errfn --isnull; then
        _io.err "$(_fn.name): cannot get args when fn is not set";
        _sys.abort;
    fi
    
    _io.err "$(_fn.name): unknown flag <$flag>";
    _sys.abort;
}
fi
###

## std sed filters.
_sed.rmws()
{
	sed 's/ //g';
}

_sys.arg()
{   
	_sys.assert.nows "$@";

    local arg="$1";
    
    if test -z "$arg"; then
        local caller=$(_fn.caller);
        _io.err "$caller: empty arg value";
        _sys.abort;
    fi

    _sys.args.ws "$1";
    _sys.out $1;

    _sys.args.errfn --clear;
}


# more advance _fn stuff.
_fn.clone()
{
    local fromfn=$(_sys.arg $1);
    local tofn=$(_sys.arg $2);

    if ! test $(type -t $fromfn) = "function"; then
        _io.err "$(_fn.name): attemps to clone non existant function <$fromfn>";
        _sys.abort;
    fi
    
    local clonebody=$(declare -f $fromfn | grep -v $fromfn);
    
    local tpl="
        $tofn()
        $clonebody
    ";

    eval $tpl
}

# null arg, ws arg, abort msgs, ...
#

nb:() { :; }

nb: below makes a difference. no err. with set -u, there is an error. 
nb: but with below also fn.error.

set +u

egfn()
{
    local a1=$(_sys.arg $1);
    local a2=$(_sys.arg ${2-'default'});

    _sys.out $a1 $a2
}

egfn 'ws ws' hithere;
