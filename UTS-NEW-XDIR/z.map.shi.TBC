#!/bin/bash

# THIS STUFF SEEMS TO WORK!


fn.return()
{
	echo "eval return $1";
}

fn.echo()
{
	echo $*;
}

fn.name()
{
	local l=${1:-1};
	echo ${FUNCNAME[$l]};
}

fn.caller()
{
	fn.name 3;
}

arg() { echo "$@"; }

err()
{
	echo $* >&2;
}

__abort()
{
	kill -9 0;
}

__match()
{
	local matchin=$(arg $1);
	shift;

	for i in "$@"; do 
		if test $matchin = $i; then 
			$(fn.return 0);
		fi
	done
	return 1;
}

___args()
{
	for i in "$@"; do
		local sedi=$(echo $i | sed 's/ /xxx/');
		if ! test "$sedi" = "$i"; then 
			err "$(fn.caller) null space in arg"
			__abort;
		fi
	done
}

__args()
{
	echo 'eval ___args "$@"'
}

flg.abort()
{
	echo '--assert --abort --ass'
}

int.even()
{ 
	$(__args)
	local fncall="$@";
	local abort=false;

	if __match $1 $(flg.abort); then
		abort=true;
		shift;
	fi

	local fncaller=$(fn.caller);
    local num=$(arg $1);

	local iseven=true;
    if ((num % 2 != 0)); then
		iseven=false;
	fi

	err iseven: $iseven, abort: $abort.

	! $iseven && $abort && ( err "$(fn.name): non even value passed, goodbye <$fncall>" >&2 ; __abort; );
	! $iseven && return 1;
	return 0;
}

nb:() { :; }
nb: above tested.

_arr.init()
{
	local -n arrref=$(arg $1);
	shift;
	arrref=("$@");
}

_arr.len()
{
	local -n arrref=$(arg $1);
	echo ${#arrref};
}

_arr.at()
{
	local -n arrref=$(arg $1);
	local arrname=$1;
	local pos=$(arg $2);
	local val=$3;

	local len=$(_arr.len arrref);
	if ((len > pos)); then
		err "array access outside range of array <$arrname> - len: $len, position: $pos"
		__abort;
	fi

	if test -z $val; then
		echo arrref[$pos];
		return 0;
	else
		arrref[$pos]=$val;
		return 0;
	fi
}

uts.arr()
{
    local flag=$(arg $1);
    local -n aref=$(arg $2);
	local val=$3;

    if test $flag = "--len"; then
        _arr.len aref;
	elif test $flag == "--at"; then
		_arr.at aref $val;
    elif test $flag == "--init"; then 
		shift;
	fi

	_arr.init mref "$@";
	return;
}

TEST HERE!

_map.init()
{
	local -n mapref=$(arg $1)
	shift

	local nargs=$#;
	int.even --assert $nargs;

	for ((i=1; i<$nargs; i+=2)); do
		local key=${!i};
		local valindex=$((i+1));
		local value=${!valindex}

		mapref[$key]=$value;
	done
	return 0;
}

_map.len()
{
    local -n m=$1;
    echo "${#m[@]}";
}

_map.keys()
{
    local -n m=$1
    echo "${!m[@]}"
}

_map.vals()
{
    local -n m=$1;
    echo "${m[@]}";
}

uts.map()
{
    local flag=$1
    shift
    local -n mref=$1;

    if test $flag = "--len"; then
        _map.len mref;
        return 0;
    fi

    if test $flag == "--keys"; then
       _map.keys mref;
       return 0;
    fi

    if test $flag == "--vals"; then
       _map.vals mref;
       return 0;
    fi

    if test $flag == "--init"; then 
		shift;
	fi

	_map.init mref "$@";
	return;
}

if test "$1" == '--testmap'; then

	_test()
	{
		echo keys:
		uts.map --keys MP;
		echo expected: today, wife, hello
		echo

		echo vals:
		uts.map --vals MP;
		echo expected: world, strife, tues
		echo

		echo len:
		uts.map --len MP
		echo expected: 3
		echo
	}

	declare -g -A MP;
	uts.map --init MP hello world wife strife today tues
	_test;

fi # end test.
