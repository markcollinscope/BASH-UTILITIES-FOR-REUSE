#/bin/bash

. uts.unit.shi

err()
{
	>&2 echo $*;
}

count()
{
	echo  $#
}

arg() 
{ 
    local ARG=$1;

    if test -z $ARG; then
		echo error;
		return 1;
    fi;
    echo $ARG
}

ref() { arg "$@"; }

function test.arg.returns.single.value()
{
	input="1 2 3 4444 555 6"
	xout=1;

	out=$(count $(arg $input));
	tst.assertSame $xout $out
}

arr.echo()
{
	local -n arr=$(ref $1);
	echo ${arr[@]}
}

function test.arr.echo()
{
	local -a in=(one two three);
	local out=$(arr.echo in);
	local xout='one two three';

	tst.assert --same $(arg $xout) $(arg $out);
}

_count() { echo $#; }

arr.len()
{
	local -n arr=$(ref $1);
	echo ${#arr[@]}
} 


function test.arr.len()
{
	local -a in=(one two three 'four five six but not really 4 5 6 - just fourth element in array');
	local xout=4;
	local out=$(arr.len in);

	tst.assert --same $xout $out;
}

arr.at()
{
	local -n arr=$(ref $1);
	local pos=$(arg $2);

	echo ${arr[$pos]}
}

function test.arr.at()
{
	local in=(one two three four);
	local len=$(arr.len in);
	local i;

	for ((i=0;i<len; i++)); do
		out=$(arr.at in $i);
		xout=${in[$i]};
		tst.assert --same $out $xout;
	done
}

fnfn()
{
	local -a argvals=(name address);
	local len=$(arr.len argvals);
	local l=100;

	fn()
	{
		local i;
		for ((i=0; i<len; i++)); do
			v=$(arr.at argvals $i)
			echo v: $v; # todo.
		done
		echo l: $l
	}

	fn;
}

function test.fn.local()
{
	echo "type: <$(type -t fn)>";
	tst.assert --same "" $(type -t fn)
}

function test.fnfn() 
{ 
	fnfn; 
}

_FN_MSG='hello'
_FN='{ echo $_FN_MSG; }'

fn.create()
{
	eval "$1() $_FN"
}

function test.fn.create()
{
	fn.create myfn
	tst.assert --same $(type -t myfn) 'function';
	tst.assert --same $(myfn) $_FN_MSG;
}


x.init()
{
	_CAUGHT=false;
	trap x.catch SIGUSR1;
}

x.clear()
{
	_ERROR=
	_CAUGHT=false;
	trap - SIGUSR1;
}

x.error()
{
	if test -z  "$_ERROR"; then
		_ERROR="$@"
	else
		echo $_ERROR;
		_ERROR=
	fi
}

x.catch() 
{		
  	_CAUGHT=true
}

# Function to raise the signal
x.raise()
{
	x.error "$@"
    kill -SIGUSR1 $$
}

_MSG='error mate'

_subsubfn() { x.raise $_MSG; }
_subfn() { _subsubfn; }

function test.except()
{
	x.init;

	x.raise;
	tst.assert --true  $_CAUGHT;

	x.clear;
	tst.assert --false $_CAUGHT;

	x.clear;
	x.init;
	x.raise $error;
	tst.assert --same $(arg $_MSG) $(arg $(x.error));
}

####
tst.run
