#!/bin/bash

. utils_globals.shi

GIT_SUMMARY=$(cat << END_GIT
Utitlites to assist in the automation of git related activities within bash scripts. Things like: What's the current git root directory? Is the cwd in a git repo? What's the current branch name? Is a commit required in the current git repo? Commit and push the current repo to the origin... etc.
END_GIT
);

if ! alreadyIncluded UTILS_GIT; then
. utils_core.shi
. utils_vb.shi

### START CONTENT

isGitRootDir()
# is the cwd a git root directory - return 0 [T] or 1 [F]
{
	if test -a ".git"; then return 0; else return 1; fi
}

isGitDir() 
# returns T/F [0/1] depending whether the cwd is in a git repo.
{
	no ne git rev-parse --is-inside-work-tree
}


gitroot() 
# echo-return the name of the root git directory given the cwd.
{
	checkIsGitDir;
	git rev-parse --show-toplevel
}

gitrootns() 
# echo-return the name of the root git directory given the cwd.
# however, remove any '/'s e.g. '/usr/include'  - will be echo-returned as '_usr_include'
# enables git root dir to be used as an identifier or filename - or context for pvars (see utils).
{
	gitroot | sed 's?/?_?g'
}

gitrootif() # [--dir <dir>]
# echo-return the root git directory given the current dir (cwd).
# if not under git control, echo-return '.' (full stop) i.e. current directory, unless
# --dir option is used, in which case echo-return <dir>.
# e.g. usage: $ cd $(gitrootif); - change to git root dir if there is not, else stay where you are.
# e.g. usage: $ FILE_LOCATION=$(gitrootif --dir $HOME); - file is either in git root dir, or home dir 
# if not under git control.
{
	DIR=.;
	eval $(valopt --dir DIR "$@");

	if isGitDir; then
		gitroot;
	else
		echo "$DIR";
	fi
}

gitCurrentBranch() 
# echo-return the current git branch
{
	V=$(git branch 2>/dev/null | grep '*' | sed 's/*//')
	V=${V:="No-Git-Branch-Available"}
	echo $V
}

checkIsGitDir() 
# error and exit if current dir is not within under git control.
{
	if ! $(isGitDir); then
		errecho "$0: Error <$(pwd)> is not under Git source control - cannot continue. Bye!"
		exiterr -k;
	fi
}

xfindgitdirs()
# recursive dir search down from cwd, echo-return all the git root dir names.
{
	for i in $(xfinddirs); do
	(
		if isdir $i; then 
            cd $i;
		    if isGitRootDir; then 
			    echo $i
		    fi
        fi
	)
	done
}

gitNeedsCommit()
# does the current git repo have data to potentially commit?
{
	checkIsGitDir;

	if ! test -z "$(git status -s)"; then
		return 0;
	else
		return 1;
	fi
}

chkGitCommitted() 
# exit with an error if there are uncommited items in this repo.
{
	if gitNeedsCommit; then 
		errecho "git commit required before using: $(script) (branch: $(gitCurrentBranch))"
		exiterr 1;
	fi
}

gitStatus()
# prints a message if the git repo which contains the cwd requires a git commit.
{
	checkIsGitDir;

	if gitNeedsCommit; then	
		errecho "GIT COMMIT REQUIRED IN: $(pwd)"
	fi
}

gitBranches()
# list all local branches
{
	checkIsGitDir;
	git branch | sed 's/\*//'
}

gitAbandonChanges()
# abandon all changes since the last commit. prints warning message.
{
	Warning "Abandon uncommitted changes?"
	git reset --hard
}

gitDoPush()
# push current repo to origin.
{
	git push origin $(gitCurrentBranch);
}

gitDoCommit() # [<message>]
# undertake a git commit using <message> - or a default message if none supplied.
{
	local MSG=${1:-"function $(fnname) - no commit message given - branch is <$(gitCurrentBranch)>"};
	git add -A
	git commit -m "$MSG"
}

gitCommitAndPush() # <messasge>
# commit changes using <message>, then push to origin.
{
	gitDoCommit	"$@"
	gitDoPush
}

gitcandpfn() # <message>
# commit changes using <message>, then push to origin - duplicate for back-compatibilty.
{ 
	gitCommitAndPush "$@"; 
}

### END CONTENT
fi
