#!/bin/bash
#
# Core functions used in all other *utils*.

_MSG="UTILS_CORE INCLUDED"
if test -z "$___UTILS_CORE"; then 
___UTILS_CORE=$_MSG

debugutils() { if ! test -z "$DEBUGUTILS"; then >&2 echo $*; fi }
debugutils $_MSG

# global values... git dir, scripts dirs, log dirs ...
_UTILS_GLOB=$(which utils_globals.shi)
if test -f "$_UTILS_GLOB"; then
. $_UTILS_GLOB;
fi

### START CONTENT
callFnIfExists() { if test "`type -t $1`" = "function" ; then $*; fi }
nostdout() { exec > /dev/null; } 	# turn off stdout. best in subshell "(" .. ")" if you must use!
nostderr() { exec 2> /dev/null; }	# turn off stderr, may screw colors stuff below.

doscriptexit() 
{ 
	local EXITCODE=$1;

	if test "$0" = "bash" || test "$0" = "sh"; then # don't exit on terminal cmd line! deeply annoying!
		2>&1 echo "'exit' called in function <${FUNCNAME[2]}> - status <$EXITCODE>"
	else
		exit $EXITCODE;
	fi
}

# use these to exit... if you want to use functions on the cmd line (in process).
exitok() { doscriptexit 0; }
exiterr() 
{ 
	local EXITCODE=1;
	if ! test -z "$1"; then EXITCODE=$1; fi

	doscriptexit $EXITCODE;
}

chkarg()	# exit if a fn arg not provided.
{
	local VARNAME=$1; 	#NB: pass $1 as MYARG not $MYARG - no "$" necessary (or permitted)
	
	local VALUE=${!VARNAME}
	local FNNAME=$(fnname)
	if test -z "$VALUE"; then 
		errecho "[$FNNAME]: Call to Fn has missing argument <$VARNAME>"
		exiterr;
	fi
} # e.g. usage: "local TEMPERATURE=$1; chkarg TEMPERATURE" - check if TEMPERATURE ($1) was passed in.

export BLACK="\e[30m"
export RED="\e[31m"		
export LIGHTRED="\e[91m"	
export GREEN="\e[32m"		
export YELLOW="\e[33m"
export BLUE="\e[34m"
export MAGNETA="\e[35m"
export CYAN="\e[36m"
export WHITE="\e[37m"
export NORMAL="\e[0m"
export RESET="\e[0m"  # same as NORMAL

setcol()
{
	local COLOR=$1; chkarg COLOR;

	echo -n -e $COLOR
	>&2 echo -n -e $COLOR
}

setcolnorm() # reset (echo) text color to normal. 
{
	echo -n -e $NORMAL
	>&2 echo -n -e $NORMAL
}
resetcol() { setcolnorm; }

errecho() {  setcol $RED; (>&2 echo "$*"); setcolnorm; } # echo to std error!

fnname() # [-l <call-fn-level>] - # e.g. "fnname -l 2"  echo fn calling fn calling this fn.
{
	local ARG_FLAG=$1;
	local ARG_LEVEL=$2;
	local DEFAULT_LEVEL=1;

	if test "$ARG_FLAG" = "-l"; 
	then 
		chkarg ARG_LEVEL;
		DEFAULT_LEVEL=$ARG_LEVEL; 
	fi
	echo "${FUNCNAME[$DEFAULT_LEVEL]}"
}

ne() { 2>/dev/null $*; }	# run command without those irritating error messages! (ne=NoError)

checkNotEmptyString() # 
{
	local ERROR_MSG="$1";
	local VALUE_TO_CHECK="$2";

	if test -z "$VALUE_TO_CHECK"; then 
		errecho "$0 - [$(fnname)] $ERROR_MSG"; 
		exit 1; 
	fi
}
# e.g. usage: 'local NAME=""; checkNotEmptyString "You forgot to give a name!" $NAME' 
# - NB: "$" is necessary here.


Usage() { errecho "$USAGE"; exit 1; }

### END CONTENT
fi 

#if test "$1" = "--testme"
#then
#	(
#		echo OKIFSHOWN
#		nostdout
#		echo ERROR IF SHOWN!
#	)
#	echo SHOULDBESHOWN
#
#	(
#		errecho OKIFSHOWN
#		nostderr
#		errecho ERROR IF SHOWN!
#	)
#	errecho SHOULDBESHOWN
#
#	(
#		# NB: running in subshell due to "exit 1" on error.
#		chkarg NOSUCHARG
#	)
#
#	errecho SHOULDBESHOWN
#fi
