#!/bin/bash
#
# Core functions used in all other *utils*.
# TBD: Unit Test Msg?

# global values... git dir, scripts dirs, log dirs ... one time include if present.
_UTILS_GLOB=$(which utils_globals.shi)
if test -f "$_UTILS_GLOB"; then
. $_UTILS_GLOB;
fi

if ! alreadyIncluded UTILS_CORE; then

### START CONTENT
callFnIfExists() { if test "$(type -t $1)" = "function" ; then $*; fi }
nostdout() { exec > /dev/null; } 	# turn off stdout. best in subshell - ( .. ) -  if you must use!
nostderr() { exec 2> /dev/null; }	# turn off stderr, best in subshell - ( .. ) -  if you must use!
null() { if test -z "$*"; then return 0; else return 1; fi }
isdir() { if test -d "$1"; then return 0; else return 1; fi }; isDir() { isdir $*; }

_doscriptexit() 
{ 
	local EXITCODE=$1;

	if test "$0" = "bash" || test "$0" = "sh"; then # don't exit on terminal cmd line! deeply annoying!
		2>&1 echo "'exit' called in function <${FUNCNAME[2]}> - status <$EXITCODE>"
	elif test "$EXITCODE" = "-k"; then
		kill 0
	else
		exit $EXITCODE;
	fi
}

# use these to exit... if you want to use functions on the cmd line (in process).
exitok() { _doscriptexit 0; }
exiterr() # -k - really exit - from multiple sub-processes as well.
{ 
	local EXITCODE=1; 
	if ! test -z "$1"; then EXITCODE=$1; fi;
	
	_doscriptexit $EXITCODE;
}

chkarg() # # e.g. usage: "local T=$1; chkarg T; # exit if T=
{
	local VARNAME="$1"; 	#NB: pass $1 as MYARG not $MYARG - no "$" necessary (or permitted)
	
	local VALUE=${!VARNAME}
	local FNNAME=$(fnname -l 2)
	if test -z "$VALUE"; then 
		errecho "[$FNNAME]: Call to Fn has missing argument <$VARNAME>"
		exiterr;
	fi
} 
chkvar() { chkarg $*; } # shown intent - when checking non arg value (e.g. ENV VAR)

export BLACK="\e[30m"
export RED="\e[31m"		
export LIGHTRED="\e[91m"	
export GREEN="\e[32m"		
export YELLOW="\e[33m"
export BLUE="\e[34m"
export MAGNETA="\e[35m"
export CYAN="\e[36m"
export WHITE="\e[37m"
export NORMAL="\e[0m"
export RESET=$NORMAL

isTerminalOutput() # is the output stream (1, 2 ...) to a terminal?
{
	local OUTPUT=1; if ! test -z "$1"; then OUTPUT="$1"; fi
    if test -t $OUTPUT; then return 0; else return 1; fi
}

UTS_NOCOLOR=${UTS_NOCOLOR:-false}
setcol() # ' export UTS_NOCOLOR=true ' -  in env. to turn color off.
# set text color.
{
	local COLOR=$1; chkarg COLOR;
	if $UTS_NOCOLOR; then return 0; fi

	if isTerminalOutput; then echo -n -e $COLOR; fi
	if isTerminalOutput 2; then >&2 echo -n -e $COLOR; fi

	return 0;
}

setcolnorm() # reset (echo) text color to normal. 
{
	setcol $NORMAL
}
resetcol() { setcolnorm; }

errecho() {  setcol $RED; (>&2 echo "$*"); setcolnorm; } # echo to std error!

fnname() # [-l <call-fn-level>] - # e.g. "fnname -l 2"  echo fn calling fn calling this fn.
# what is the current function name (the function calling this one)
{
	local ARG_FLAG=$1;
	local ARG_LEVEL=$2;
	local DEFAULT_LEVEL=1;

	if test "$ARG_FLAG" = "-l"; 
	then 
		if test -z "$ARG_LEVEL"; then errecho "[fnname -l NO LEVEL PROVIDED]"; exiterr; fi
		DEFAULT_LEVEL=$ARG_LEVEL; 
	fi
	echo "${FUNCNAME[$DEFAULT_LEVEL]}"
}

ne() { 2>/dev/null $*; }	# run command without those irritating error messages! (ne=NoError)

checkNotEmptyString()
# e.g. usage: 'local NAME=""; checkNotEmptyString "You forgot to give a name!" $NAME' 
# - NB: "$" is necessary here.
{
	local ERROR_MSG="$1";
	local VALUE_TO_CHECK="$2";

	if test -z "$VALUE_TO_CHECK"; then 
		errecho "$0 - [$(fnname -l 2)] $ERROR_MSG"; 
		exiterr
	fi
}

# grep but exclude certain patterns.
xgrep() { ne grep "$@" | grep -v -E "$(getGrepExcludes)"; }

# default Usage function. 
Usage() { USAGE="$(echo "$USAGE" | sed 's?\./??' )"; errecho "$USAGE"; exiterr; }

if null "$UTS_NOAUTOARGS"; then 
	if test "$1" = "--help"; then callFnIfExists Usage; fi
	if test "$1" = "-?"; then callFnIfExists Usage; fi
fi

fi
