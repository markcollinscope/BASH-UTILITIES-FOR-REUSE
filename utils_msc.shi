#!/bin/bash

. utils_globals.shi
if ! alreadyIncluded UTILS_MSC; then
. utils_core.shi
. utils_vb.shi
. utils_fd.shi

delimit() # $1 => %%$1%%, [-d <_ARG>] - use $_ARG instead of '%%'.
{
	local _ARG=%%
	if ! test $1 = '-d'; then _ARG=$2; shift 2; fi

	vbarg _ARG
	echo $_ARG$1$_ARG;
}

stripwhite() # $1 => $1 but without excess whitespace (\t and space) & control chars
{
	RES="$1";

	RES=$(echo $RES | xargs)		# obscure trick.
 	echo "$RES"
}

count() { echo $#; }

concat() # [-c <string>] - e.g. concat a b c => 'abc', concat -c : a b c => 'a:b:c'
{ 

	local RES="";
	local ADDCHAR="";
	if test "$1" = "-c"; then TOADDCHAR=$2; shift 2; fi;

	if test "$1" = "-s"; then 
		shift; 
		RES=$(concat -c ' ' "$*");
	else
		for i in "$@"; do 
			RES="$RES$ADDCHAR$i";
			ADDCHAR=$TOADDCHAR
		done;
	fi

	echo "$RES"
}

randomString() 
{
	NUM=$1
	if test -z "$NUM"; then NUM=10; fi

	chars="abcdefghijklmnopqrstuvwxyz"

	for ((i=0; i<$NUM; i++))
	do
		echo -n ${chars:RANDOM%${#chars}:1}
	done
}


roundDown()
{
	NUM=$1
	checkNotEmptyString "$(fnname) requires a number argument" $NUM

	echo "$NUM/1" | bc
}


getDirs() # echo full path name of dirs, from cwd, recursive, exclude unwanted. [-x]: exclude cwd. TODO
{
	DIR="$(pwd)/"; 
	if test "$1" = "-x"; then _FILTER="| grep -v -E ^$DIR$"; fi

	find "$(pwd)/" -type d -print $_FILTER | grep -v -E "$(getGrepExcludes)";
}

nds() # no double slash - e.g. "nds echo $PATH" - echo PATH with // => /. # TODO - Deprecate...
{
	ne eval "$@" | sed 's?\/\/?/?g';
}

explode() # explode "ABCDE" => A B C D E
{
	echo $1 | grep -o .
}

# END CONTENT
fi
