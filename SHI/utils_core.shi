#!/bin/bash
#
# Core functions used in all other *utils*.

# global values... git dir, scripts dirs, log dirs ... one time include if present.
_UTILS_GLOB=$(which utils_globals.shi)
if test -f "$_UTILS_GLOB"; then
. $_UTILS_GLOB;
fi

if ! alreadyIncluded UTILS_CORE; then

### START CONTENT
nostdout() { exec > /dev/null; } 	# turn off stdout. best in subshell - ( .. )
nostderr() { exec 2> /dev/null; }	# turn off stderr, best in subshell - ( .. )

null() { if test -z "$*"; then return 0; else return 1; fi }; # for readibility.
isdir() { if test -d "$1"; then return 0; else return 1; fi }; isDir() { isdir "$@"; }  # for readibility.
isfile() { if test -f "$1"; then return 0; else return 1; fi }; isFile() { isfile "$@"; } # for readibility.

script() { echo $(basename $0); }; 	# print base of current bash script *file* name.
scriptName() { script; }; 			# print base of current bash script *file* name.

callFnIfExists() { if test "$(type -t $1)" = "function" ; then "$@"; fi } # <fn> - call <fn> if it exists.

Usage() { USAGE="$(echo "$USAGE" | sed 's?\./??' )"; errecho "$USAGE"; } # default Usage function. Autocalled by bash utils.

_doscriptexit() # internal only.
{ 
	local EXITCODE=$1;

	if test "$0" = "bash" || test "$0" = "sh"; then # don't exit on terminal cmd line! deeply annoying!
		2>&1 echo "'exit' called in function <${FUNCNAME[2]}> - status <$EXITCODE>"
	elif test "$EXITCODE" = "-k"; then
		kill 0
	else
		exit $EXITCODE;
	fi
}

exitok() # no args.
# exit with ok status (0). If in terminal (command line) mode - don't exit terminal -instaad print a message.
{ 
	_doscriptexit 0; 
}; 

exiterr() # arg: <exit code>; opts: -k - exit from multiple nested sub-processes as well. 
# exit with non-ok status ($1). If in terminal (command line) mode - don't exit terminal -instaad print a message.
{ 
	local EXITCODE=1; 
	if ! test -z "$1"; then EXITCODE=$1; fi;
	
	_doscriptexit $EXITCODE;
}

chkarg() # arg: <bash variable name> [<level>]
# usage: chkarg X [level] ; - is X set to a value? if not, error. nb: X is passed without $
# level - call level of function name to print for error. e.g. 2 - the function that called chkarg (this function).
{
	local VARNAME=$1; 	
	local LEVEL=${2:-2};
	
	local VALUE=${!VARNAME}
	local FNNAME=$(fnname -l $LEVEL)

	if null "$VALUE"; then 
		errecho "[$FNNAME]: Call to fn has missing argument <$VARNAME>"
		exiterr;
	fi
} 
chkvar() { chkarg "$@"; } # see chkarg
chkval() { chkarg "$@"; } # see chkarg

setvar() # <bash var name> <value>
# set <bash var> to <value> - if no <value> - error and exit.
{ 
	local VARNAME="$1"; chkarg VARNAME;
	local VALUE="$2"; 

	local THISFN=$(fnname);
	local CALLINGFN=$(fnname -l 2)

	if null "$VALUE"; then
		errecho "$(script): <$THISFN> (caller: <$CALLINGFN>, var: <$VARNAME>) - no value given for second arg (\$2)"
		exiterr -k;
	fi

	eval "$VARNAME"="\"$VALUE\""; 
} 

// VT100 codes.
export BLACK="\e[30m"
export RED="\e[31m"		
export LIGHTRED="\e[91m"	
export GREEN="\e[32m"		
export YELLOW="\e[33m"
export BLUE="\e[34m"
export MAGENTA="\e[35m"
export CYAN="\e[36m"
export WHITE="\e[37m"
export NORMAL="\e[0m"
export RESET=$NORMAL

isTerminalOutput() 
# is the output stream (1, 2 ...) to a terminal?
{
	local OUTPUT=1; if ! null "$1"; then OUTPUT="$1"; fi
    if test -t $OUTPUT; then return 0; else return 1; fi
}

# set to <true> to turn color off.
UTS_NOCOLOR=${UTS_NOCOLOR:-false}

setcol() # <color code>
# set text color - see predefined VT100 codes above.
{
	local COLOR=$1; chkarg COLOR;
	if $UTS_NOCOLOR; then return 0; fi

	if isTerminalOutput; then echo -n -e $COLOR; fi
	if isTerminalOutput 2; then >&2 echo -n -e $COLOR; fi

	return 0;
}

setcolnorm() 
# reset (echo) text color to 'normal'. 
{
	setcol $NORMAL
}
resetcol() { setcolnorm; } # see setcolnorm();

scrCurPos() # [ <x> <y> ]
# Position the cursor at(row,column(relative top rhs) as per $1, $2 - or at 0,0 if either args not given.
{
	local ROW=$1;
 	local COL=$2;
 	
 	if ! null $ROW && ! null $COL; then
 		local OUTPUT="\e[""${ROW}"";""${COL}""H"
 		echo -ne "$OUTPUT"
 	else
 		echo -ne "\e[H"
 	fi
}

scrClear() # no args.
# clear the screen.
{
	echo -ne "\e[2J"
}

errecho() # [-s] - precede error with script name.
# print message to stderr.
{  
	setcol $RED; 
	if test "$1" = "-s"; then
		>&2 echo "$(script): "
		shift;
	fi
	>&2 echo "$*" 
	resetcol; 
}

errfnecho() # always precedes error with script and bash function name.
# print message to stderr.
{ 
	errecho -s "[${FUNCNAME[1]}()]: $*"; 
}

fnname() # [-l <call-fn-level>] - # e.g. "fnname -l 2"  echo fn calling fn calling this fn.
# what is the current function name (the function calling this one)
{
	local ARG_FLAG=$1;
	local ARG_LEVEL=$2;
	local FN_LEVEL=1;

	if test "$ARG_FLAG" = "-l"; then 
		if test -z "$ARG_LEVEL"; then errfnecho "[fnname -l NO LEVEL PROVIDED]"; exiterr -k; fi
		FN_LEVEL=$ARG_LEVEL; 
	fi
	echo "${FUNCNAME[$FN_LEVEL]}"
}

ne() { 2>/dev/null $*; }	# run command without those irritating error messages! (ne: No Error) e.g. $ no errecho hello - no output
no() { >/dev/null $*; }		# run command without std output! (no: No Output) - e.g. $ no echo hello - no output

checkNotEmptyString() # <msg> [ <bash var name> ] - deprecated - use chkarg().
# e.g. usage: $ 'local NAME=""; checkNotEmptyString "You forgot to give a name!" $NAME' 
{
	local ERROR_MSG="$1";
	local VALUE_TO_CHECK="$2";

	if test -z "$VALUE_TO_CHECK"; then 
		errecho "$0 - [$(fnname -l 2)] $ERROR_MSG"; 
		callFnIfExists Usage
		exiterr
	fi
}

xgrep() # <list of grep args>
# grep, but exclude certain patterns from results (e.g. 'node_modules')- see UTS_GREPEXCLUDEFILES - defaults set.
{ 
	grep "$@" | grep -v -E "$(getGrepExcludes)"; 
}

xfind() # <list of find args>
# find, but exclude certain patterns from results (e.g. 'node_modules')- see UTS_GREPEXCLUDEFILES - defaults set.
{ 
	find "$@" | grep -v -E "$(getGrepExcludes)"; 
}

# END
fi
