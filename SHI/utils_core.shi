#!/bin/bash
#
# Core functions used in all other *utils*.

# global values... git dir, scripts dirs, log dirs ... one time include if present.
_UTILS_GLOB=$(which utils_globals.shi)
if test -f "$_UTILS_GLOB"; then
. $_UTILS_GLOB;
fi

if ! alreadyIncluded UTILS_CORE; then

### START CONTENT
callFnIfExists() { if test "$(type -t $1)" = "function" ; then "$@"; fi }
nostdout() { exec > /dev/null; } 	# turn off stdout. best in subshell - ( .. )
nostderr() { exec 2> /dev/null; }	# turn off stderr, best in subshell - ( .. )
null() { if test -z "$*"; then return 0; else return 1; fi }
isdir() { if test -d "$1"; then return 0; else return 1; fi }; isDir() { isdir "$@"; }
isfile() { if test -f "$1"; then return 0; else return 1; fi }; isFile() { isfile "$@"; }
script() { echo $(basename $0); }; scriptName() { script; }

# default Usage function. 
Usage() { USAGE="$(echo "$USAGE" | sed 's?\./??' )"; errecho "$USAGE"; exiterr 1; }

_doscriptexit() 
{ 
	local EXITCODE=$1;

	if test "$0" = "bash" || test "$0" = "sh"; then # don't exit on terminal cmd line! deeply annoying!
		2>&1 echo "'exit' called in function <${FUNCNAME[2]}> - status <$EXITCODE>"
	elif test "$EXITCODE" = "-k"; then
		kill 0
	else
		exit $EXITCODE;
	fi
}

# use these to exit... if you want to use functions on the cmd line (in process).
exitok() { _doscriptexit 0; }; 
exiterr() # -k - really exit - from multiple sub-processes as well.
{ 
	local EXITCODE=1; 
	if ! test -z "$1"; then EXITCODE=$1; fi;
	
	_doscriptexit $EXITCODE;
}

chkarg() # chkarg X - is $X set to a value? if not, error.
{
	#nb: pass $1 as MYARG not $MYARG - no "$" necessary (or permitted)
	local VARNAME=$1; 	
	local LEVEL=2; if ! null $2; then LEVEL=$2; fi
	
	local VALUE=${!VARNAME}
	local FNNAME=$(fnname -l $LEVEL)

	if null "$VALUE"; then 
		errecho "[$FNNAME]: Call to Fn has missing argument <$VARNAME>"
		exiterr;
	fi
} 
chkvar() { chkarg "$@"; }
chkval() { chkarg "$@"; }

setvar() 
{ 
	local VARNAME="$1"; chkarg VARNAME;
	local VALUE="$2"; 

	local THISFN=$(fnname);
	local CALLINGFN=$(fnname -l 2)

	if null "$VALUE"; then
		errecho "$(script): <$THISFN> (caller: <$CALLINGFN>, var: <$VARNAME>) - no value given for second arg (\$2)"
		exiterr -k;
	fi

	eval "$VARNAME"="\"$VALUE\""; 
} 

setvarif() { setvar AVAR "$1" 3; AVAL="$2"; if ! null "$AVAL"; then eval "$AVAR"="$AVAL"; fi; };  # TODO: check.

export BLACK="\e[30m"
export RED="\e[31m"		
export LIGHTRED="\e[91m"	
export GREEN="\e[32m"		
export YELLOW="\e[33m"
export BLUE="\e[34m"
export MAGENTA="\e[35m"
export CYAN="\e[36m"
export WHITE="\e[37m"
export NORMAL="\e[0m"
export RESET=$NORMAL

isTerminalOutput() # is the output stream (1, 2 ...) to a terminal?
{
	local OUTPUT=1; if ! null "$1"; then OUTPUT="$1"; fi
    if test -t $OUTPUT; then return 0; else return 1; fi
}

UTS_NOCOLOR=${UTS_NOCOLOR:-false}
setcol() # ' export UTS_NOCOLOR=true ' -  in env. to turn color off.
# set text color.
{
	local COLOR=$1; chkarg COLOR;
	if $UTS_NOCOLOR; then return 0; fi

	if isTerminalOutput; then echo -n -e $COLOR; fi
	if isTerminalOutput 2; then >&2 echo -n -e $COLOR; fi

	return 0;
}

setcolnorm() # reset (echo) text color to normal. 
{
	setcol $NORMAL
}
resetcol() { setcolnorm; }

scrCurPos() # Position the cursor at(row,column(relative top rhs) as per $1, $2 - or at 0,0 if args not given.
{
	local ROW=$1;
 	local COL=$2;
 	
 	if ! null $ROW && ! null $COL; then
 		local OUTPUT="\e[""${ROW}"";""${COL}""H"
 		echo -ne "$OUTPUT"
 	else
 		echo -ne "\e[H"
 	fi
}

scrClear() # clear the screen.
{
	echo -ne "\e[2J"
}

errecho() # -s - precede error with script name.
{  
	setcol $RED; 
	if test "$1" = "-s"; then
		>&2 echo "$(script): "
		shift;
	fi
	>&2 echo "$*" 
	resetcol; 
}

errfnecho() { errecho -s "[${FUNCNAME[1]}()]: $*"; }

fnname() # [-l <call-fn-level>] - # e.g. "fnname -l 2"  echo fn calling fn calling this fn.
# what is the current function name (the function calling this one)
{
	local ARG_FLAG=$1;
	local ARG_LEVEL=$2;
	local FN_LEVEL=1;

	if test "$ARG_FLAG" = "-l"; then 
		if test -z "$ARG_LEVEL"; then errfnecho "[fnname -l NO LEVEL PROVIDED]"; exiterr -k; fi
		FN_LEVEL=$ARG_LEVEL; 
	fi
	echo "${FUNCNAME[$FN_LEVEL]}"
}

ne() { 2>/dev/null $*; }	# run command without those irritating error messages! (ne: No Error)
no() { >/dev/null $*; }		# run command without std output! (no: No Output)

checkNotEmptyString()
# e.g. usage: 'local NAME=""; checkNotEmptyString "You forgot to give a name!" $NAME' 
{
	local ERROR_MSG="$1";
	local VALUE_TO_CHECK="$2";

	if test -z "$VALUE_TO_CHECK"; then 
		errecho "$0 - [$(fnname -l 2)] $ERROR_MSG"; 
		callFnIfExists Usage
		exiterr
	fi
}

# grep/find but exclude certain patterns.
xgrep() { grep "$@" | grep -v -E "$(getGrepExcludes)"; }
xfind() { find "$@" | grep -v -E "$(getGrepExcludes)"; }

if null "$UTS_NOAUTOARGS"; then 
	if test "$1" = "--help"; then errecho "help details: "; callFnIfExists Usage; callFnIfExists Help; fi
	if test "$1" = "-?"; then errecho "help details: "; callFnIfExists Usage; callFnIfExists Help; fi
fi

# END
fi
