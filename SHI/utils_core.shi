#!/bin/bash
#
# Core functions used in all other *utils*.

# global values... git dir, scripts dirs, log dirs ... one time include if present.
_UTILS_GLOB=$(which utils_globals.shi)
if test -f "$_UTILS_GLOB"; then
. $_UTILS_GLOB;
fi

if ! alreadyIncluded UTILS_CORE; then

### START CONTENT
callFnIfExists() { if test "$(type -t $1)" = "function" ; then $*; fi }
nostdout() { exec > /dev/null; } 	# turn off stdout. best in subshell - ( .. ) -  if you must use!
nostderr() { exec 2> /dev/null; }	# turn off stderr, best in subshell - ( .. ) -  if you must use!
null() { if test -z "$*"; then return 0; else return 1; fi }
isdir() { if test -d "$1"; then return 0; else return 1; fi }; isDir() { isdir $*; }

_doscriptexit() 
{ 
	local EXITCODE=$1;

	if test "$0" = "bash" || test "$0" = "sh"; then # don't exit on terminal cmd line! deeply annoying!
		2>&1 echo "'exit' called in function <${FUNCNAME[2]}> - status <$EXITCODE>"
	elif test "$EXITCODE" = "-k"; then
		kill 0
	else
		exit $EXITCODE;
	fi
}

# use these to exit... if you want to use functions on the cmd line (in process).
exitok() { _doscriptexit 0; }; 
exiterr() # -k - really exit - from multiple sub-processes as well.
{ 
	local EXITCODE=1; 
	if ! test -z "$1"; then EXITCODE=$1; fi;
	
	_doscriptexit $EXITCODE;
}

chkarg() # - local T=$1; chkarg T; - e.g. typical usage - exiterr if T=""
{
	local VARNAME="$1"; 	#NB: pass $1 as MYARG not $MYARG - no "$" necessary (or permitted)
	local LEVEL=2
	if ! null $2; then LEVEL=$2; fi
	
	
	local VALUE=${!VARNAME}
	local FNNAME=$(fnname -l $LEVEL)
	if null "$VALUE"; then 
		errecho "[$FNNAME]: Call to Fn has missing argument <$VARNAME>"
		exiterr;
	fi
} 
chkvar() { chkarg "$@"; }
chkval() { chkarg "$@"; }

setvar() { AVAR="$1"; chkarg AVAR 3; AVAL="$2"; chkarg AVAL 3; eval "$AVAR"="\"$AVAL\""; }; 
setvarif() { setvar AVAR "$1" 3; AVAL="$2"; if ! null "$AVAL"; then eval "$AVAR"="$AVAL"; fi; }; 

## TODO: Rationalise arg, val, var ... across all chk fns, set fns... etc.

## TODO - mv this - does it belong in core. is used by scripts, not fns (yet) ???
UTS_MAXARGS=99 # arbitrary but large - upper limit
chkargcount() 
#
# [-l] - lower limit only
# check argument ($@) count is- between lower, upper inclusive - otherwise exit with message.
#
{
	if test "$1" = "-l"; then LOWERONLY=true; shift; fi
	setvar LOWERLIMIT $1; shift;
	if ! $LOWERONLY; then UPPERLIMIT=$2; shift; else UPPERLIMIT=$UTS_MAXARGS; fi

	chkarg UPPERLIMIT
	local COUNT=$(count "$@");
	if (( $COUNT < $LOWERLIMIT )) || (( $COUNT > $UPPERLIMIT)); then

		local MSG="Incorrect number of arguments - "
		if $LOWERONLY; then 
			MSG=$(concat "$MSG" "expected more than: $LOWERLIMIT - got $COUNT")
		else
			MSG=$(concat "$MSG" "expected (between): $LOWERLIMIT and $UPPERLIMIT - got $COUNT");
		fi
		errecho "$MSG"

		callFnIfExists Usage;
		exiterr -k;
	fi
}

export BLACK="\e[30m"
export RED="\e[31m"		
export LIGHTRED="\e[91m"	
export GREEN="\e[32m"		
export YELLOW="\e[33m"
export BLUE="\e[34m"
export MAGENTA="\e[35m"
export CYAN="\e[36m"
export WHITE="\e[37m"
export NORMAL="\e[0m"
export RESET=$NORMAL

isTerminalOutput() # is the output stream (1, 2 ...) to a terminal?
{
	local OUTPUT=1; if ! test -z "$1"; then OUTPUT="$1"; fi
    if test -t $OUTPUT; then return 0; else return 1; fi
}

UTS_NOCOLOR=${UTS_NOCOLOR:-false}
setcol() # ' export UTS_NOCOLOR=true ' -  in env. to turn color off.
# set text color.
{
	local COLOR=$1; chkarg COLOR;
	if $UTS_NOCOLOR; then return 0; fi

	if isTerminalOutput; then echo -n -e $COLOR; fi
	if isTerminalOutput 2; then >&2 echo -n -e $COLOR; fi

	return 0;
}

setcolnorm() # reset (echo) text color to normal. 
{
	setcol $NORMAL
}
resetcol() { setcolnorm; }

setcurpos() # Position the cursor at row, column (offset from top rhs) as per $1, $2 - or at 0,0 if args not given.
{
	local ROW=$1;
 	local COL=$2;
 	
 	if ! null $ROW && ! null $COL; then
 		local OUTPUT="\e[""${ROW}"";""${COL}""H"
 		echo -ne "$OUTPUT"
 	else
 		echo -ne "\e[H"
 	fi
}

errecho() {  setcol $RED; (>&2 echo "$*"); setcolnorm; } # echo to std error!

fnname() # [-l <call-fn-level>] - # e.g. "fnname -l 2"  echo fn calling fn calling this fn.
# what is the current function name (the function calling this one)
{
	local ARG_FLAG=$1;
	local ARG_LEVEL=$2;
	local DEFAULT_LEVEL=1;

	if test "$ARG_FLAG" = "-l"; 
	then 
		if test -z "$ARG_LEVEL"; then errecho "[fnname -l NO LEVEL PROVIDED]"; exiterr; fi
		DEFAULT_LEVEL=$ARG_LEVEL; 
	fi
	echo "${FUNCNAME[$DEFAULT_LEVEL]}"
}

ne() { 2>/dev/null $*; }	# run command without those irritating error messages! (ne=NoError)
no() { >/dev/null $*; }		# run command without irritating output.

checkNotEmptyString()
# e.g. usage: 'local NAME=""; checkNotEmptyString "You forgot to give a name!" $NAME' 
{
	local ERROR_MSG="$1";
	local VALUE_TO_CHECK="$2";

	if test -z "$VALUE_TO_CHECK"; then 
		errecho "$0 - [$(fnname -l 2)] $ERROR_MSG"; 
		callFnIfExists Usage
		exiterr
	fi
}

# grep/find but exclude certain patterns.
xgrep() { grep "$@" | grep -v -E "$(getGrepExcludes)"; }
xfind() { find "$@" | grep -v -E "$(getGrepExcludes)"; }

# default Usage function. 
Usage() { USAGE="$(echo "$USAGE" | sed 's?\./??' )"; errecho "$USAGE"; exiterr; }

if null "$UTS_NOAUTOARGS"; then 
	if test "$1" = "--help"; then callFnIfExists Usage; fi
	if test "$1" = "-?"; then callFnIfExists Usage; fi
fi

# END
fi
