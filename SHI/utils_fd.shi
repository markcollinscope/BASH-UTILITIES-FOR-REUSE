#!/bin/bash

. utils_core.shi

if ! alreadyIncluded UTILS_FD; then

### START CONTENT

# checkxxx - check something, exit with error if there's a problem.
# ensurexxx - check if something is done, if not, do it.

ensuredeleted() 
{
	local FILE_OR_DIR=$1; chkarg FILE_OR_DIR;
	
	if test -e $FILE_OR_DIR; then
		vbecho "deleted $FILE_OR_DIR"
		rm -rf $FILE_OR_DIR
	fi
}

checkfileexists()
{
	local FILE=$1; chkarg FILE;
	local MSG="($2)"

	if ! test -f $FILE; then
		errecho "$0: file <$1> does not exist $MSG"
		callFnIfExists Usage
		exiterr;
	fi
}

checkdirexists()
{
	DIR="$1"; chkarg DIR;

	MSG="Directory <$DIR> does not exist"

	if ! null "$2"; then MSG="$2"; fi

	if ! test -d "$DIR"; then
		errecho "$MSG"
		callFnIfExists Usage
		exiterr;
		return 1;
	fi
	return 0;
}

ensuredirexists()
{
	DIR="$1"; chkarg DIR; 

	if ! test -d "$DIR"; then
		mkdir -p $DIR
		vbfnecho "Created: $DIR"
	fi
	local XC=$?
	
	if test $XC -ne 0 ; then 
		errecho "Unable to create directory $DIR"
		exiterr; 
	fi
}

fdmatch() # is there a matching file or dir for shell glob pattern.
{
	stat -t $1 > /dev/null 2>&1
}

tmpFile()	# [ <num> ] - number of characters in filename suffix - default 5.
{
	local LEN="$1"
	if null "$LEN"; then LEN=5; fi

	PREFIX="UTILS_FD"
	
	local TMP="/tmp/$PREFIX.$(randomString $LEN)"
	echo $TMP
}


fileecho() # [--rm] <message> <file> [...<file>] - (write msg to file(s), clear file first if '--rm')
{
	local CLEAR_FILE_BEFORE_NEW_WRITE=false
	if test "$1" = "--rm"; then CLEAR_FILE_BEFORE_NEW_WRITE=true; shift; fi

	local MSG="$1"; shift; chkarg MSG;

	local LIST_OF_FILES="$*"; chkarg LIST_OF_FILES;

	for i in $LIST_OF_FILES; do
		if $CLEAR_FILE_BEFORE_NEW_WRITE; then
			rm -r $i;
		fi
		echo "$MSG" >> "$i";
	done
}

findFile() # -d <dir> or -h (home directory);
{
	FLAG=$1
	DIR=.; 
	if test "$FLAG" = "-d"; then 
		DIR="$2"; shift 2;
   	elif test "$FLAG" = "-h"; then
		DIR=~; shift;
	fi

	FILE=$1; chkarg FILE

	find $DIR -name $FILE -print -quit 2>/dev/null
}
findfile() { findFile $*; }

backupFile()
{
	FILE=$1; chkarg FILE;

	ensuredirexists $UTS_BACKUPDIR
	BACKUPFILE=$UTS_BACKUPDIR/$FILE.$(date --iso-8601)

	if test -e $FILE; then		
		vbecho "FILE <$FILE> IS BEING BACKED UP TO <$BACKUPFILE>"
		cp -r $FILE $BACKUPFILE;
	fi
}
backupDir() { backupFile $*; }

getPath() # [-h] - under HOME dir only
{
	local HOMEONLY=false;
	if test "$1" = "-h"; then HOMEONLY=true;fi

	TFILE1=$(tmpFile)
	TFILE2=$(tmpFile)

	IFS=':'
	for i in $PATH; do
		if test -d "$i"; then
		(
			cd $i; pwd; # full path to dir.
		)
		fi
	done | sort | uniq > $TFILE1
	
	if $HOMEONLY; then 
		grep "$HOME" < $TFILE1 > $TFILE2;
	else
		mv $TFILE1 $TFILE2
	fi
	cat $TFILE2
}

mkfindor() # make a find 'or expression' with many filename patterns ("$@").
{
	setvar PATT $1
	shift;

	RETVAL="-name $PATT"

	for i in "$@"; do
		RETVAL=$(concat -s $RETVAL -o -name $i)
	done	

	echo "$RETVAL"
}

xfinddirs() # ([-i]: include current dir) - find non excluded dirs below current.
{
	if test "$1" = "-i"; then
		vbecho "-i"
		xfind . -type d
	else
		vbecho "no -i"
		xfind . -type d | grep -v '^\.$'
	fi
}

xforeachdir() # run a command in each xfinddirs directory.
{
	setvar CMD "$*"

	for i in $(xfinddirs); do
	(
		vbfnecho $i;
		cd $i;
		eval $CMD;
	)
	done
}

xfindfiles() # find files below current dir that match the glob pattern (ls style) in $@.
{
	xfind . -type f $(mkfindor "$@")
}

xfindfilesgrep() # -s: show grep results; list files containing a pattern - no grep output.
{
	local SHOW=false; if test "$1" = "-s"; then SHOW=true; shift; fi

	setvar PATTERN "$1"; shift;

	for i in $(xfindfiles "$@"); do
		if no xgrep "$PATTERN" "$i"; then
			setcol $GREEN
			echo $i;
			setcol $CYAN
			if $SHOW; then xgrep "$PATTERN" "$i"; fi
			resetcol
		fi
	done
}

xfindcwd() # list files (applying exclusions) in current dir.
{
	for i in $(xfind . -maxdepth 1 | sed 's?\./??g' | grep -v '^\.'); do
		if test -f $i; then
			echo $i;
		fi
	done
}

### END
fi
