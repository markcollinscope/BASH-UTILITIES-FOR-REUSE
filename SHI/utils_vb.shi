#!/bin/bash

# utils to enable addtional (perhaps debug) information to be printed (to stderr) only when UTS_VERBOSE flag is set.

. utils_core.shi
if ! alreadyIncluded UTILS_VB; then 


### START CONTENT

VBFLAG=${UTS_VBFLAG:-'--vb'}	# can override from environment.

setVerbose() 	{ export UTS_VERBOSE=true; export UTS_VERBOSEFLAG="$VBFLAG"; }	# preferred way to set UTS_VERBOSE=true;
getVerbose()	{ if $UTS_VERBOSE; then return 0; else return 1; fi; }
verbose()		{ getVerbose; }
resetVerbose() 	{ export UTS_VERBOSE=false; export UTS_VERBOSEFLAG=""; }	# preferred way to set UTS_VERBOSE=false;
resetVerbose;

vbvar() # for debug -  print variable - BASHVAR - no $required.
{
	local BASHVAR=$1; chkarg BASHVAR;
	vbecho "$(basename $0) [${FUNCNAME[1]}()]: $BASHVAR: <${!BASHVAR}>";
}

vbecho()	{ if $UTS_VERBOSE; then setcol $YELLOW; (>&2 echo $*); setcolnorm; fi }
vbfnecho()	{ vbecho "$(basename $0) [${FUNCNAME[1]}()]: $*"; }
vbsleep() { if $UTS_VERBOSE; then sleep $*; fi }

checkIfVerbose() # quick parse for $VBFLAG flag as $1.
{
	if test "$1" = "$VBFLAG"; then
		setVerbose;
		return 0;
	fi
	return 1;
}

if null "$UTS_NOAUTOARGS"; then
	if checkIfVerbose $1; then shift; fi
fi

# parses $1 (only!) and if $VBFLAG, sets verbose, removes -v as arg.
# so scripts will *automatically* set UTS_VERBOSE if $VBFLAG is first argument
# and these utils are included (using '.'' or 'source')

### END CONTENT
fi
