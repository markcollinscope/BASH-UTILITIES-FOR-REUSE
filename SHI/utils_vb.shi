#!/bin/bash

# utils to enable addtional (perhaps debug) information to be printed (to stderr) only when UTS_VERBOSE flag is set.

. utils_core.shi
if ! alreadyIncluded UTILS_VB; then 


### START CONTENT

VBFLAG=${UTS_VBFLAG:-'--vb'}	# can override from environment.

setVerbose() 	{ export UTS_VERBOSE=true; export UTS_VERBOSEFLAG="$VBFLAG"; }	# preferred way to set UTS_VERBOSE=true;
getVerbose()	{ if $UTS_VERBOSE; then return 0; else return 1; fi; }
verbose()		{ getVerbose; }
resetVerbose() 	{ export UTS_VERBOSE=false; export UTS_VERBOSEFLAG=""; }	# preferred way to set UTS_VERBOSE=false;
resetVerbose;

vbvar() # for debug -  print variable - BASHVAR - no $required.
{
	local BASHVAR=$1; chkarg BASHVAR;
	vbecho "$(basename $0) [${FUNCNAME[1]}()]: $BASHVAR: <${!BASHVAR}>";
}

vbecho()	{ if $UTS_VERBOSE; then setcol $YELLOW; (>&2 echo $*); setcolnorm; fi }
vbfnecho()	{ vbecho "$(basename $0) [${FUNCNAME[1]}()]: $*"; }
vbsleep() { if $UTS_VERBOSE; then sleep $*; fi }

checkIfVerbose() # quick parse for $VBFLAG flag as $1.
{
	if test "$1" = "$VBFLAG"; then
		setVerbose;
		return 0;
	fi
	return 1;
}

# autoparse verbose flag.

if ! $UTS_NOAUTOARGS; then
	if checkIfVerbose $1; then shift; fi
fi
# nb - re above: parses $1 (only) and if same value as $VBFLAG, sets verbose,
# also removes VBFLAG from the including script's command line args - so is 
# transparent to that script.

# overall effect: scripts will *automatically* set UTS_VERBOSE if $VBFLAG is first argument
# to the bash script that includes this file.

### END CONTENT
fi
