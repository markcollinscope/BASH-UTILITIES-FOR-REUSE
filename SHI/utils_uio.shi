#!/bin/bash

. utils_core.shi
if ! alreadyIncluded UTILS_UIO; then

FFLAG=${UTS_FFLAG:-"--ff"}	# can override from environment.

UTS_FORCE=false;	# override manual intervention requests
UTS_FORCEFLAG="$FFLAG";	# empty or FFLAG (pass onto subscripts - subscript $UTS_FORCEFLAG)

setForce() 		{ export UTS_FORCE=true; export UTS_FORCEFLAG="$FFLAG"; }
resetForce()	{ export UTS_FORCE=false; export UTS_FORCEFLAG=""; }
getForce()		{ if $UTS_FORCE; then return 0; else return 1; fi; }
force()			{ getForce; }

checkIfForce() # check $1 - if it's the force flag (FFLAG) set force mode (setForce()).
{
	if test "$1" = "$UTS_FORCEFLAG"; then setForce; return 0; else return 1; fi
}

hitAnyKeyToContinue() # [<message>] - print <message> and wait for key press (enter).
{
	local MSG=$1

	if $(force); then return; fi
	
	MSG="$MSG - hit enter to continue - ctl-c to exit"
	errecho $MSG
	read x
}

Warning() # [<message-to-show>] - show message - wait for yes/n response, exit on 'n'.
# [-n] - do not exit on "no" reponse - default is to exit.
{
	local EXITONNO=true; if test "$1" = "-n"; then EXITONNO=false; shift; fi
	local OPTIONAL_MSG="$1";
	local MSG="CONTINUE?" # default.

	local RETURN_VAL=0;
	if $(force); then return $RETURN_VAL; fi

	if ! test -z "$OPTIONAL_MSG"; then MSG="$OPTIONAL_MSG"; fi
	MSG="$MSG [yes|n]"

	while true; do
		errecho $MSG
		read yn
		case $yn in
			[Yy]es ) 
				break;;
			[Nn]* ) 
				if "$EXITONNO";
				then 
					exiterr;
				else 
					RETURN_VAL=1; break; 
				fi;;
			* ) errecho "Please answer yes or no (n).";;
		esac
	done
	return $RETURN_VAL;
}

if ! $UTS_NOAUTOARGS; then
	if checkIfForce "$1"; then shift; fi # NB: use --vb before --ff if necessary.
fi

#CONTENT ENDS
fi
