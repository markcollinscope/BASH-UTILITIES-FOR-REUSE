#!/bin/bash

. utils_globals.shi
if ! alreadyIncluded UTILS_OPTS; then

. utils_core.shi
. utils_msc.shi

__USAGE_FILE=$(tmpFile);

rm -f $__USAGE_FILE;

__DOCFLAG="--rem"
__OPTIONS="Options:"

addOptRem()
{
	setvar FLG "$1";
	setvar TXT "$2";

	if ! test -f $__USAGE_FILE; then 
		echo $__OPTIONS > $__USAGE_FILE;
	fi

	echo "$FLG $TXT" >> $__USAGE_FILE;
}

getOptUsage() 
# print option documentation a given by '--rem' argument to xxxopt functions.
# -n: don't print "Options:" at head of option list.
{
	local FILTER=false;

	if test "$1" = "-n"; then 
		FILTER=true;
	fi

	if test -f $__USAGE_FILE; then
		$FILTER || cat $__USAGE_FILE;
		$FILTER && ( cat $__USAGE_FILE | grep -v "$__OPTIONS" );
	fi
}

processRem() 
{
	local USEDOC="$1"
	local RET=

	if test "$USEDOC" = "$__DOCFLAG"; then
		setvar TEXT "$2";
		setvar FLAG "$3";
		addOptRem "$FLAG" "$TEXT";
		RET="shift 2";
	fi
	echo $RET;
}

binopt()
{
	eval $(processRem "$@");

	setvar FLAG "$1"
	setvar VAR "$2"
	setvar DEFAULT_VALUE "$3"
	setvar OTHER_VALUE "$4"
	shift 4;

	local ARGS=

	EVAL="$VAR=\"$DEFAULT_VALUE\""
	while ! null "$1"; do
		if test "$1" = "$FLAG"; then
			EVAL="$VAR=\"$OTHER_VALUE\""
		else
			ARGS="$ARGS \"$1\"";
		fi
		shift;
	done


	echo "set -- $ARGS; $EVAL"
}

boolopt() # FLAG [e.g -x]  VAR [e.g. X_A_BASHVAR]
{
	eval $(processRem "$@");
	
	setvar FLAG "$1"
	setvar VAR "$2"
	shift 2;


	binopt "$FLAG" "$VAR" false true "$@"
}

valopt() 	# e.g. script --file afilename ; use 'afilename' if given with --file option.
{

	eval $(processRem "$@");

	setvar FLAG "$1"
	setvar VAR "$2"
	shift 2;

	local ARGS=
	local EVAL=

	while ! test -z "$1"; do
		if test "$1" = "$FLAG"; then
			EVAL="$VAR=\"$2\""
			shift 2;
		else
			ARGS="$ARGS \"$1\"";
			shift
		fi
	done

	echo "set -- $ARGS; $EVAL "
}

errifopt() # it is an error if there are any more options (-*) in $@
{
	while ! test -z "$1"; do
		if [[ "$1" =~ -.* ]]; then
			errecho "Unknown option: \"$1\""
			callFnIfExists Usage;
			exiterr -k;
		fi
		shift;
	done
}

Usage() # override if using this include.
{
	OPTIONS="$(getOptUsage)"
	>&2 cat<<<$USAGE
	>&2 cat<<<$OPTIONS
	exiterr 1
}

_UTS_MAXARGS=9999 # arbitrary but large - upper limit
chkargcount() 
# [-l] - lower limit only
# check argument ($@) count is- between lower, upper inclusive - otherwise exit with message.
{
	LOWERONLY=false; 
	if test "$1" = "-l"; then 
		vbfnecho "Lower Limit Only"; 
		LOWERONLY=true; 
		shift; 
	fi
	setvar LOWERLIMIT $1;
	shift;

	if ! $LOWERONLY; then 
		setvar UPPERLIMIT $1; 
		vbfnecho "Upper Limit: $UPPERLIMIT"
		shift; 
	else 
		UPPERLIMIT=$_UTS_MAXARGS; 
	fi
	chkarg UPPERLIMIT
	vbvar LOWERLIMIT
	vbvar UPPERLIMIT

	local COUNT=$(count "$@");

	if (( $COUNT < $LOWERLIMIT )) || (( $COUNT > $UPPERLIMIT)); then
		vbecho "LIMIT CHECK FAILED";
		local MSG="Incorrect number of arguments - "
		if $LOWERONLY; then 
			MSG=$(concat "$MSG" "only $COUNT arguments given - more than: $LOWERLIMIT required")
		elif (( $LOWERLIMIT == $UPPERLIMIT )); then
			MSG=$(concat "$MSG" "$COUNT arguments given - expected $LOWERLIMIT");
		else
			MSG=$(concat "$MSG" "expected (between): $LOWERLIMIT and $UPPERLIMIT - got $COUNT");
		fi
		errecho "$MSG"

		callFnIfExists Usage;
		exiterr -k;
	fi
}

# END CONTENT
fi


