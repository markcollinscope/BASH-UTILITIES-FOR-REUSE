#!/bin/bash

. utils_globals.shi
if ! alreadyIncluded UTILS_OPTS; then

. utils_core.shi
. utils_msc.shi

# functions to enable printing of 'autocomplete' command to be eval'd to setup cmd line autocomplete (bash autocomplete).

__USEAUTOCOMPLETE=false;
__AUTOCOMPLETEOPTION="--autocomplete"

# nb: at present this is focused on git-autocompletion - e.g. optautocomplete "_git_custo_command() { _git_checkout; } ..."

optautocomplete() # if opt chosen, echo $1 back to be used to create an autocomplete option.
{
	setvar AC "$*"
	if $__USEAUTOCOMPLETE; then
		echo $AC;
		exitok;
	fi
}

if ! $UTS_NOAUTOARGS; then
	if test "$1" = "$__AUTOCOMPLETEOPTION"; then  
		__USEAUTOCOMPLETE=true;
		shift;
	fi
fi

# to print usage information

__USAGE_FILE=$(tmpFile);

rm -f $__USAGE_FILE;

__DOCFLAG="--rem"
__OPTIONS="Options:"

_addOptRem()
{
	setvar FLG "$1";
	setvar TXT "$2";

	if ! test -f $__USAGE_FILE; then 
		echo $__OPTIONS > $__USAGE_FILE;
	fi

	echo "$FLG $TXT" >> $__USAGE_FILE;
}

_processRem() 
{
	local USEDOC="$1"
	local RET=

	if test "$USEDOC" = "$__DOCFLAG"; then
		setvar TEXT "$2";
		setvar FLAG "$3";
		_addOptRem "$FLAG" "$TEXT";
		RET="shift 2";
	fi
	echo $RET;
}

getOptUsage() # [-n]
# print option documentation a given by '--rem' argument to xxxopt functions.
# -n: don't print "Options:" at head of option list.
{
	local FILTER=false;

	if test "$1" = "-n"; then 
		FILTER=true;
	fi

	if test -f $__USAGE_FILE; then
		$FILTER || cat $__USAGE_FILE;
		$FILTER && ( cat $__USAGE_FILE | grep -v "$__OPTIONS" );
	fi
}

binopt()
{
	eval $(_processRem "$@");

	setvar FLAG "$1"
	setvar VAR "$2"
	setvar DEFAULT_VALUE "$3"
	setvar OTHER_VALUE "$4"
	shift 4;

	local ARGS=

	EVAL="$VAR=\"$DEFAULT_VALUE\""
	while ! null "$1"; do
		if test "$1" = "$FLAG"; then
			EVAL="$VAR=\"$OTHER_VALUE\""
		else
			ARGS="$ARGS \"$1\"";
		fi
		shift;
	done


	echo "set -- $ARGS; $EVAL"
}

boolopt() # FLAG [e.g -x]  VAR [e.g. X_A_BASHVAR]
{
	eval $(_processRem "$@");
	
	setvar FLAG "$1"
	setvar VAR "$2"
	shift 2;


	binopt "$FLAG" "$VAR" false true "$@"
}

valopt() 	# e.g. script --file afilename ; use 'afilename' if given with --file option.
{

	eval $(_processRem "$@");

	setvar FLAG "$1"
	setvar VAR "$2"
	shift 2;

	local ARGS=
	local EVAL=

	while ! test -z "$1"; do
		if test "$1" = "$FLAG"; then
			EVAL="$VAR=\"$2\""
			shift 2;
		else
			ARGS="$ARGS \"$1\"";
			shift
		fi
	done

	echo "set -- $ARGS; $EVAL "
}

errifopt() # exit with error if there are options (-*) in $@; autoparse --help or -? to show usage/help.
{
	vbfnecho;
	if ! $UTS_NOAUTOARGS; then # first arg only.
		vbfnecho "check first arg: $1"
		if test "$1" = "--help"; then vbfnecho "is --help"; shift; callFnIfExists Usage; callFnIfExists Help; exitok; fi
		if test "$1" = "-?"; then vbfnecho "is -?"; shift; callFnIfExists Usage; callFnIfExists Help; exitok; fi
	fi

	while ! test -z "$1"; do
		case "$1" in
		-*)
			errecho "Unknown option: \"$1\""
			vbfnecho "Usage: $(type -t Usage)";
			Usage;
			exiterr -k;
			;;
		esac
		shift;
	done
}

Usage() # print $USAGE and also print option despcripts defined using boolopt, valopt, etc.
{
	OPTIONS="$(getOptUsage)"
	>&2 cat<<<$USAGE
	>&2 cat<<<$OPTIONS
}

_UTS_MAXARGS=9999 # arbitrary but large - upper limit
chkargcount() # check argument ($3+) count is between $1-lower, $2-upper inclusive - otherwise error exit.
# [-l] - lower limit only
{
	LOWERONLY=false; 
	if test "$1" = "-l"; then 
		vbfnecho "Lower Limit Only"; 
		LOWERONLY=true; 
		shift; 
	fi
	setvar LOWERLIMIT $1;
	shift;

	if ! $LOWERONLY; then 
		setvar UPPERLIMIT $1; 
		vbfnecho "Upper Limit: $UPPERLIMIT"
		shift; 
	else 
		UPPERLIMIT=$_UTS_MAXARGS; 
	fi
	chkarg UPPERLIMIT
	vbvar LOWERLIMIT
	vbvar UPPERLIMIT

	local COUNT=$(count "$@");

	if (( $COUNT < $LOWERLIMIT )) || (( $COUNT > $UPPERLIMIT)); then
		vbecho "LIMIT CHECK FAILED";
		local MSG="Incorrect number of arguments - "
		if $LOWERONLY; then 
			MSG=$(concat "$MSG" "only $COUNT arguments given - more than: $LOWERLIMIT required")
		elif (( $LOWERLIMIT == $UPPERLIMIT )); then
			MSG=$(concat "$MSG" "$COUNT arguments given - expected $LOWERLIMIT");
		else
			MSG=$(concat "$MSG" "expected (between): $LOWERLIMIT and $UPPERLIMIT - got $COUNT");
		fi
		errecho "$MSG"

		callFnIfExists Usage;
		exiterr -k;
	fi
}

# END CONTENT
fi

