#!/bin/bash

. utils_globals.shi
if ! alreadyIncluded UTILS_MSC; then
. utils_core.shi
. utils_vb.shi
. utils_fd.shi


stripwhite() # $1 => $1 but without excess whitespace (\t and space) & control chars
{
	RES="$1";

	RES=$(echo $RES | xargs)		# obscure trick.
 	echo "$RES"
}

count() { echo $#; }

concat() # [-c <string>] - e.g. concat a b c => 'abc', concat -c : a b c => 'a:b:c'
{ 

	local RES=
	local ADDCHAR=
	local TOADDCHAR=

	if test "$1" = "-c"; then TOADDCHAR=$2; shift 2; fi;

	if test "$1" = "-s"; then 
		shift; 
		RES=$(concat -c ' ' "$*");
	else
		for i in "$@"; do 
			RES="$RES$ADDCHAR$i";
			ADDCHAR=$TOADDCHAR
		done;
	fi

	echo "$RES"
}

delimit() # $1 => %%$1%%, [-d <_LIMITCHAR>] - use $_LIMITCHAR instead of '%%'.
{
	local _LIMITCHAR=%%

	if test "$1" = '-d'; 
	then 	
		_LIMITCHAR=$2; 
		shift 2; 
	fi

	echo $_LIMITCHAR$1$_LIMITCHAR;
}

randomString() 
{
	NUM=$1
	if test -z "$NUM"; then NUM=10; fi

	chars="abcdefghijklmnopqrstuvwxyz"

	for ((i=0; i<$NUM; i++))
	do
		echo -n ${chars:RANDOM%${#chars}:1}
	done
}

isNum()
{
	setvar NUM $1

	if [[ "$NUM" =~ ^[0-9]*$ ]]; then
		return 0;
	else
		return 1;
	fi
}

roundDown()
{
	NUM=$1
	checkNotEmptyString "$(fnname) requires a number argument" $NUM

	echo "$NUM/1" | bc
}


getDirs() # echo full path name of dirs, from cwd, recursive, exclude unwanted. [-x]: exclude cwd. TODO
{
	DIR="$(pwd)/"; 
	if test "$1" = "-x"; then _FILTER="| grep -v -E ^$DIR$"; fi

	find "$(pwd)/" -type d -print $_FILTER | grep -v -E "$(getGrepExcludes)";
}

nds() # no double slash - e.g. "nds echo $PATH" - echo PATH with // => /. # TODO - Deprecate...
{
	ne eval "$@" | sed 's?\/\/?/?g';
}

explode() # explode "ABCDE" => A B C D E
{
	echo $1 | grep -o .
}

printbetween()
{
	eval $(boolopt -n NUMERIC "$@");
	setvar START "$1"
	setvar END "$2"
	setvar FILE "$3"

	if ! $NUMERIC; then
    	if ! grep $START.*$END $FILE; then
        	sed -n "/$START/,/$END/p" $FILE
    	fi
	else
		sed -n "${START},${END}p" $FILE
	fi
}

len() # how many chars in $1 - length.
{
	setvar STRING "$1"
	count $(explode "$STRING")
}

echoPadded()
{
	setvar PADLEN $1;
	shift;
	setvar TEXT "$*";

	if ! isNum $PADLEN; then
		echo notnum
		errecho "$(fnname) - must supply a number as argument";
		callFnIfExists Usage;
		exiterr 1;
	fi	

	local TEXTLEN=$(len $TEXT)
	local PADDING=$((PADLEN - TEXTLEN));

	vbvar TEXTLEN
	vbvar PADLEN
	vbvar PADDING

	echo -n $TEXT;
	for ((i=0; i<PADDING; i++)) do 
		echo -n " ";  
	done
}

errechoPadded()
{
	>&2 echoPadded $*
}

# END CONTENT
fi
