_.stack()
{
	local i=0;
	local fnname=$(_.fnname $i);
	local tmp=$(mktemp);
	(
		echo 'stack trace:'
		while test $fnname != main; do
			i=$((i+1));
			fnname=$(_.fnname $i)
			echo "stack($i): $fnname"
		done
	) > $tmp;
	echo $tmp
}

_.exit() {  exit $1; }
_.err() { >&2 echo $*; }
_.errcat() { >&2 cat $1; }

_.debug() { return 0; }
_.dbg() { if _.debug; then _.err $*; fi; }

_.pre() { echo uts; }
_.ext() { echo shi; }
_.Q() { echo $*; }
_.isnull() { test -z "$1"; }
_.br() { echo "<$*>"; }
_.isfn() { type -t "$1" = 'function'; }

_.randstr() { _.rmdot $(_.rmslash $(mktemp) ); };
_.unreachable() { _.progerr 'error - unreachable code section reached'; }

_.fnname() { local level=${1:-0}; level=$((level + 1)); echo "${FUNCNAME[$level]}"; }
_.progerr() { _.abort '...programming error detected - function:' $(_.br $(_.fnname 1)) ' ...' $*; }

_.arg() { if test -z "$*"; then _.abort "argument error in $(_.fnname)"; fi; echo $*; }
_.abort() { 
	local i=0; local max=6; 
	local stackfile=$(_.stack);
	_.errcat $stackfile;
	_.err "aborting..$*"; 
	_.err
	exit 1; 
}

_.rmchars() { local str=$(_.arg $1); shift; echo $* | sed "s?$str??g"; }
_.rmslash() { _.rmchars '/' $*; }
_.rmdot() { _.rmchars '\.' $*; }

_.fnconst()
{
	local name=$1;
	local val=$2;
	local fntempate="
		$name()
		{
			echo $val;
		}
	";
	eval "$fntempate";
}

_.fnrandom()
{ 
	local name=$(_.arg $1);
	echo $name; 

	local value=$(_.randstr);

	echo value: $value
	echo newfn: $name
}

echo here
_.fnrandom usedvar;
echo here
usedvar;

echo TESTING HERE TESTING HERE TESTING HERE
exit;

_.used() 
{
	local -n isused=$(_usedvar);
	test "$isused" != 0;
	if $?; then echo isused; else echo notused; fi
	local used=$?

	isused=0;
	return $used;
}

chkused() 
{	
	if _.used; then echo used; fi
}

echo checkingused
chkused;
chkused;
chkused;
chkused;
exit;

set -e;

_.use()
{
	if test -z $(_.Q $1); then
		_.abort "$(_.fnname): no argument given.";
	fi
	local import=$(_.pre).$1.$(_.ext);
	if _.isnull $(which $import); then
		>&2 echo "_.use - not such file to import $(_br $import)";
		_exit 1;
	fi
	. $import;
}

_.fnbody()
{
	local fn=$(_.arg $1);
	local body=$( declare -f $fn | grep -v $fn );
	echo "$body"
}

_.fnclone()
{
	local from=$(_.arg $1);
	local to=$(_.arg $2);

	if ! _.isfn $from; then
		_.abort "not a function $(_.br $from)";
		_.progerr;
	fi

	local fnbody=$( $(_.fnbody $from) | grep -v $from )
	local fntemplate="
		$to()
		$fnbody
	"
	eval "$fntempate"
}

