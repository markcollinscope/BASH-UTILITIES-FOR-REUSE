	_.randstr() { echo $(_.cat RAND_ $(_.rmdot $(_.rmslash $(mktemp /tmp/candelete_XXXXXXXXXXXXXXXXXXX))) ); };
	
	_.modname()
	{ 
		local str=$(basename $(_.arg $1));
		local pre=$(_.prefix);
		local suf=$(_.suffix);

		echo $str | sed "s/$pre//g" | sed "s/$suf//g";
	}

	_.fnconst()
	{
		local name=$(_.arg $1);
		local val=$2;
		if _.isnull $val; then val=$name; fi

		local fntemplate="
			$name()
			{
				echo $val;
			}
		";
		_.eval "$fntemplate";
	}

	_.fnbody()
	{
		local fn=$(_.arg $1);

		if ! _.isfn $fn; then
			_.abort "not a function $(_.br $fn)";
		fi

		local body=$( declare -f $fn | grep -v $fn | grep -v '{' | grep -v '}' );
		echo "$body"
	}

	_.fnclone()
	{
		local from=$(_.arg $1);
		local to=$(_.arg $2);

		local fnbody=$(_.fnbody $from);

		local fntemplate="
			function $to()
			{
				$fnbody ;
			}
		"
		eval $fntemplate;
	}

	_.fngetset()
	{
		local varname=$(_arg $1);
		local value=$2;

		local private_global=$(_randstr);

		local fntemplate="
			$varname()
			{
				declare -g $private;

				if test \$# == 0;  then
					echo $private_global;
				else
					$private_global=$value;
				fi
			}
		"
		_.eval $fntempate
	}

	_.fnconst flag.getset --getset
	
	_.fnrefprivate()
	{
		local flag=$(flag.getset);
		local opt=$(_.arg $1);
		local dogetset=1;

		if test $opt == $gsflag; then
			dogetset=0;
			shift;
		fi

		local name=$(_arg $1);
		local value=$(_.randstr);

		if !dogetset; then
			_.fnconst $name $value
		else

	}

	_.contained_in()
	{
		local value=$(_.arg $1);
		shift;

		local i;
		for i in "$@"; do
			if test $value == $i; then
				return 0;
			fi
		done
		return 1;
	}

	err() { _.err $*; } # todo: remove.

	_.set() {  set -o | grep $1.*on >/dev/null 2>/dev/null; }

	_fnconst flag.off --off
	
	_.strict() 
	{	
		if test $1  == $(flag.off); then
			set +u;
		else
			set -u;
		fi
	}
	
	_.strict;
fi
