start()
{
	echo
	echo START $1;
}

endof()
{
	echo END OF PART $1
	echo
}

decl()
{
	declare -A $1;
}

if false; then
start 0;
	decl themap
endof 0
fi

vb()
{
	echo "$@"
	eval "$@"
}

if false; then
start 1
declare -A m
m[a]=aaa
m[b]=bbb
m[c]=ccc

echo ${m[a]}
echo ${!m[@]}
endof 1
fi

nth() { local n=$1; shift; echo [$n]: ${!n}; }

map.init()
{
	local -n amap=$1;
	shift;

	for ((k=1; k<$#; k=k+2)); do
		local v=$((k+1));
		local key=${!k};
		local value=${!v}

		amap[$key]=$value;
		echo k: $key, v: ${amap[$key]}
	done
}

map.len()
{
	local -A -n amap=$1;
	local len=${#amap[@]};
	echo $len;
	return 0;
}

if true; then
	start INITLEN
	vb map.init m1 K1 V1 K2 V2
	vb map.len m1
	endof INITLEN
fi

map.echo()
{
	local -n am=$1;

	local i;
	local ks=("${!am[@]}");

	for i in "${ks[@]}"; do
		echo "key: $i" 
		echo "value: ${am[$i]}"
	done
	return 0;
}

map()
{
#	if test $1 == --decl; then
#		declare -g -A $1;
#		return 0;
#	fi
#	
	if test $1 == --init; then
		shift; map.init "$@"; return 0;

	elif test $1 == --len; then
		shift; map.len "$@"; return 0;

	elif test $1 == --echo; then
		shift; map.echo "$@"; return 0;
	fi
}

if false; then
start LEN
declare -A tmpmap;
vb tmpmap[a]=aa;
vb tmpmap[b]=bb;
echo length:
map --len tmpmap;
endof LEN
fi

start LEN2
vb map --init anymp 1 111 2 222
vb map --len anymp
vb map --init themap 1 111
vb map --len themap
endof LEN2


start LEN3
vb map --init notdeclared 1 111
vb map --len notdeclared
endof LEN3

start ECHO
vb map --init echome K1 111 K2 222 K3 333
vb map --len echome
vb map --echo echome
endof ECHO
