opt wish list:

fn.default --name <name> --val <value> ? sets the value (based on name).  deafult 'fn.std'. 
fn.default --fn <fnname> -- args...
- no --fn means current fn.
- no --name means 'current function name as name - consistent, but only one'
- no --value --err

all defaults. some generated functionally? dynamically.

opt --default cool. yep.

opt.bool (defaults to false, unless already set!)

fn.default 

variable type: fn.static?  -- a 'ref type'?
arg --fn?

list.null() { :; } - is that okay?
list.null --err (autoparse option).

uts or fn 'storage'?

uts.const could be global?
opt.const subselect from set of values?
fn.const ...

fn.const --all --except <set> --only <set> --none (no point) - or perhaps to force an error?

fn.const()
{\


fn.const --name <n>
uts.const -n name


opt.bool --nd (no dash needed). otherwise could be dangerous.
opt.bool --nd

opt.const all (--all)
opt.const except (--except).
opt.const only (--only).
opt.const none --none.
opt.const bool null --null?
opt.const val name <v> --val? -- why would we want that?
opt.const err --err?

Are they local? or 'static fn options'?
Possible to tell if 'mutually recursive or recursive call?.

PRIORITISE!

opt.const -o|--option --name <n> - 
	-o - return the option string - e.g. opt.type --rem ... --rem ...
opt.const -f|--flag <name> - return the 'normalised' form of the flag (s).
		-s -single char value or err.
		-a or --all 


- if poss, no eval. or option to do either?
- opt flags - allow - -- or no - at all. default to -- for long, - for short.
- _opt.flag => $1 <$flag> => convert a -, -- or no -s flag to 'standard' format. => ? 'opt:value' ? (type opt?)
- opt -v|--value multiple possible values for flag.
- opt.set <flag> - flag - is it used? bool - its set. val - have to check for value.
- opt.value <flag> - return value of flag. bool opts - return 0/1 or true/false. val opts - error if not set --noerr option (const).

	- multi-value flags - opt.set/opt.value uses 'core' one. which is first one, perhaps. have to keep a map.
	o if opt.set delete; then ...;  fi
	o if opt.set filename; then ...; fi

opt.const --flag? 
opt.const parse?
opt.const return standard values of whatever.

opt.const arg => return const arg.

use:
	- opt.const.fn - auto delegate (here fn is arg).


str.predot -n (default 1)
str.postdot -n (default 1)
str.lastdot post the final dot. 
str.lastdot -n 3 the n'th from last values.
str.between -l v1 -u v2 or str.between v1 v2 <string>
str.substr - look at bash standard stuff again.


better str.pre  post last --match _
default - dot? str.pre means
enable reset of defaults?


fn.delegate -- set value1 value2 value3 value4 .. etc 
	- default fn delegation

(parse numbers?) --auto?
opt.arg -1

opt.auto - parse a std list of flags. --except (not that one) - but then, don't have to use.

opt. --nodash ? allow non-dash flags? e.g. set all; set none; ? set --all; set --none;
opt.arg -f 

- opt.passthru --all --only '1 2 3 4' - std.format. --except 'a b c d' ...
	- bool can just be passed if set? (only)?
	- vals - can be passed thru if value set? auto-all?
	- --ifset (only pass if set? on values?

- when using passthru - would want 'descriptions' of opts from lower level.
	- if script - perhaps 'get opts/descriptions as super-flag on script?
	- if fn - perhaps similar?

- opt --const ? save a 'const option'? (low-p)

----------------
vbstack() ...

date -d @1609459200 "+%Y-%m-%d %H:%M:%S" - date Unix epoch to std format.

--------
whitespace [[:space:]] or \s using grep -P.

; | & ' " \ $ ` ( ) [ ] [[ ]] { } * ? ! ~ < > %

---------------- things that bash is sensitive to ---------------------
see also summary above.

Semicolon (;): Used to separate multiple commands written on a single line.
Pipe (|): Used for piping the output of one command as input to another.
Ampersand (&): Used to run a command in the background.
Single Quote ('): Used for strong quoting; everything inside the single quotes is treated as literal text.
Double Quote ("): Used for weak quoting; allows for variable expansion and command substitution.
Backslash (\): Used as an escape character.
Dollar Sign ($): Used for variable expansion and command substitution.
Backtick (`): Used for command substitution (though $(...) is preferred).
Parentheses (( and )): Used for grouping commands and command substitution.
Brackets ([ and ]): Used for test conditions; also, [[ and ]] for enhanced test conditions.
Braces ({ and }): Used for parameter expansion, brace expansion, and code blocks.
Asterisk (*): Used as a wildcard for filename expansion.
Question Mark (?): Used as a single character wildcard for filename expansion.
Exclamation Mark (!): Used for event designators in history expansion and logical negation in conditions.
Tilde (~): Represents the home directory.
Angle Brackets (< and >): Used for input and output redirection.
Percent (%): Used in job control.

========================
date functions...

date1="2024-04-23"

date2="2024-04-24"

# eval bash-cmds-to-end-of-line => just run bash on: bash-cmds-to-end-of-line
# but pre-eval:
#	- \$ expressions are evaluated and substituted in.
#	- as per any other cmd/fn... eval is just another cmd/fn.

# Convert dates to seconds since Unix epoch
date1_seconds=$(date -d "$date1" +%s)
date2_seconds=$(date -d "$date2" +%s)

if [ $date1_seconds -eq $date2_seconds ]; then
    echo "Dates are equal"
elif [ $date1_seconds -gt $date2_seconds ]; then
    echo "$date1 is later than $date2"
else
    echo "$date1 is earlier than $date2"
fi

# Add 2 hours and 30 minutes to the current date and time
new_datetime=$(date -d "+2 hours 30 minutes" +"%Y-%m-%d %H:%M")

# Add 1 hour and 15 minutes to a specific date and time
specific_datetime="2024-04-23 14:30"
new_datetime=$(date -d "$specific_datetime + 1 hour 15 minutes" +"%Y-%m-%d %H:%M")

subtract 1 hour and 45 minutes from the current date and time
new_datetime=$(date -d "-1 hour 45 minutes" +"%Y-%m-%d %H:%M")

# Subtract 2 hours and 10 minutes from a specific date and time
specific_datetime="2024-04-23 14:30"
new_datetime=$(date -d "$specific_datetime - 2 hours 10 minutes" +"%Y-%m-%d %H:%M")

subtract 1 day from the current date
new_date=$(date -d "1 day ago" +"%Y-%m-%d")

# Subtract 1 month from the current date
new_date=$(date -d "1 month ago" +"%Y-%m-%d")

# Subtract 1 year from the current date
new_date=$(date -d "1 year ago" +"%Y-%m-%d")


# Add 1 day to the current date
new_date=$(date -d "1 day" +"%Y-%m-%d")

# Add 1 month to the current date
new_date=$(date -d "1 month" +"%Y-%m-%d")

# Add 1 year to the current date
new_date=$(date -d "1 year" +"%Y-%m-%d")


=================================


FUNCTION & VARIABLE RENAME LIST inc ENV VARS.
<old> [<old...>] -> <new> [<alt-new...>] | dep/del + # notes.
scriptName -> dep
getGlobBackupDir -> utsVar -B -b |--backup-dir  # for all exported UTS_ values.

sSUTS_BACKUPDIR export?
UTS_BASHINCLUDE - rename - is .shi?
UTS_EXCLUDE - grep.
TS_FORCE - ok.
UTS_FORCEFLAG - ok.
UTS_HELPFLAG - ok.
UTS_LOGDIR - export?
UTS_NOAUTOARGS - ok.
UTS_NOCOLOR - ok.
UTS_PVARDIR export.
UTS_SCRIPTDIR - ??? review.
UTS_SCRIPTTPL - .tpl ?
UTS_SUNIT - .sht?
UTS_VERBOSE - internal only.
UTS_VERBOSEFLAG - ok? or export?

GLOBAL RENAME LIST:
-	utsPrivate =>
-	verbose => utsVerbose() --get --set - 
-	UTS_VERBOSE => private.
-	check other private names.
-	utils_globals => uts_devtools.

PREFIX for Exported Functions.

===
$(script) - QUICK - realpath/fullpath option.

======================================================
======================================================
Standard Dir Search Path Utils:
0. override path - if given.
1. gitroot;
2. home;
3. local-dir?

StdSearchPath() -d Opt?
- -d used if given
- gitroot, then home, then local?
- grep search to find out how used...

======================================================

ORGANISE THIS FILE => PLAN FOR FIRST OFFICIAL RELEASE
-	must have changes.
-	auto-release process.
-	docco update - minor upgrades to how done.
-	if easy - autoname - autoalias.
-	use alias - for fns. Upgrade ffn, fndef.

INIT IDEAS FOR PLAN (ABOVE):
x.	Use: Reltodo for mandatory check list stuff.
x.	Must: -d|--define ...
x.  Must: works with all not.
x.	Should: autoalias... utsAutoAlias - utsNaming.
x.	Should: use tdd ... autobash ... <move sh-unit to uts>
x.	Could: first ds? using jq? experiment? set: --init|--set --get (default) --list (bash loop format). --pp (pretty print). --vbpp - if verbose.
x.	Could: typedata? dynamic dispatch? 2nd pass!
x.	Wont: opts --strict <enforce naming> ...

-	boolopt, etc, valopt allow --noset? for boolopt -> leave as null value not false?
-	opt NAME => T/F


============================

**** here or scr.
fnAsScript scriptAsFn ?

*****************
uts_env
- evar NAME -d / --default <DEFAULT> / do vb stuff in it.
- --vb - --vbs 

**** ???
valopt -u - is used? valopt --isused xxx_opt


******************
convert uts to use function fn { } style of definition for public functions.
*******************
extend gitrootif function with '--dir' option as alternative to '.' default.
*******************

o _vb ...
vbpusht vbpushf vbpop

********************
default values --hh --ff - what was wrong with -h, -f.

********************
o OPTS:
vb-show-ops ... or print values on verbose flag. verbose is better - I think.
something like:
--hh: default shows all the auto-processed args in UTS. 

*********************
__LIB_XXX__ - std lib var name.
utsPrivate xxx
utsPrivate NAME - get, set based on args. Adds __XXX__ to ensure safety.a
	--get (default).
	--set (optional arg takes value).

*****
getExludes, etc...  utsExcludes (arg sets, no arg gets)... 

utsAutoArgs - autoprocessed values ...
utsAutoArgs --add

********************
Options:
1.	Multiple flags as per => '--xx|-x|--yyyy'
2.	multi-opt => $(multiopt ... --flag VAR "$@");
	- continue processing ongoing cmd line args as '--flag' options until either (a) end of input, or (b) next --flag.
	- limitations - cannot terminate a multi-opt with a normal argument - wouldn't know difference.

********************
o UTILS_GIT?
	- chkGitIsCommitted <error-msg>?

*******************
o Sort out docco -bash script.

*******************
UTS_SCRIPTROOT -- helper functions use. Not good, I think as not really a UTS_ thing...
*******************

NEW-
-	uts_ds (data structures).
-	uts_props (properties, initially files/directories) prop --declare , prop --has prop --val (default t/f - other if arg given).
-	prop --edit.

NEW-
substWithNull $1 $2 - substitutes $1 to null ("") in $2

---
DONE DONE DONE!!!

cdgitroot - change to git root directory if this is a git repo, otherwise stay where you are!
decide if origin/lappie is of any use to anyone! => done as gitrootif function. 
o DEFAULT-VAR stuff.  see default isDefault in _msc.shi

EVAL - add check for --val XXX where XXX is missing (no arg supplied).
